<!doctype html><html lang=en-US><head><meta charset=UTF-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=robots content="index, follow"><meta name=author content="dilag"><meta name=description content="square attack on reduced AES rounds"><link rel=author type=text/plain href=/humans.txt><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon href=/favicon.ico type=image/x-icon><link rel=icon href=https://dilagluc.github.io/images/favicon.min.svg type=image/svg+xml><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=msapplication-TileImage content="/mstile-144x144.png"><meta name=theme-color content="#494f5c"><meta name=msapplication-TileColor content="#494f5c"><link rel=mask-icon href=/safari-pinned-tab.svg color=#494f5c><meta itemprop=name content="Cryptanalyse intégrale sur AES à tours réduits: l'attaque dite carrée"><meta itemprop=description content="square attack on reduced AES rounds"><meta itemprop=datePublished content="2023-07-19T02:08:37+02:00"><meta itemprop=dateModified content="2023-07-19T02:08:37+02:00"><meta itemprop=wordCount content="1387"><meta itemprop=keywords content="Crypto,Aes"><meta property="og:url" content="https://dilagluc.github.io/en/posts/2023/crypto/aes/square-attack-aes/"><meta property="og:site_name" content="Blog"><meta property="og:title" content="Cryptanalyse intégrale sur AES à tours réduits: l'attaque dite carrée"><meta property="og:description" content="square attack on reduced AES rounds"><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-19T02:08:37+02:00"><meta property="article:modified_time" content="2023-07-19T02:08:37+02:00"><meta property="article:tag" content="Crypto"><meta property="article:tag" content="Aes"><meta name=twitter:card content="summary"><meta name=twitter:title content="Cryptanalyse intégrale sur AES à tours réduits: l'attaque dite carrée"><meta name=twitter:description content="square attack on reduced AES rounds"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Cryptanalyse intégrale sur AES à tours réduits: l'attaque dite carrée","name":"Cryptanalyse intégrale sur AES à tours réduits: l\u0027attaque dite carrée","description":"square attack on reduced AES rounds","keywords":["crypto","aes"],"articleBody":"Dans l’article Chiffrement AES - Introduction , on a eu à étudier et comprendre le fonctionnement du chiffrement AES. On se pose maintenant la question de savoir quelles sont les attaques possibles sur ce chiffrement. Dans cet article, nous étudierons l’attaque dite carrée sur un AES à tours réduits.\nIntroduction La cryptanalyse intégrale est une technique de cryptanalyse applicable sur les chiffrements par blocs basés sur un réseau de substitution-permutation. Elle a été conçu pour la première fois pour attaquer un chiffrement du nom de SQUARE (d’où le nom square attack), mais fut plus tard généralisée à d’autres algorithmes de chiffrement qui ne sont pas de type SQUARE. Elle est plus généralement connu sous le nom d’attaque carrée (square attack).\nLa cryptanalyse intégrale utilise un ensemble ou plusieurs ensembles de clairs choisis dont une partie reste constante et l’autre partie varie couvrant toutes les possibilités.\nOn verra dans la suite comment fonctionne ce type d’attaque sur un chiffrement AES à tours réduits.\nL’attaque carrée Comme dit précédemment cette attaque avait été conçu pour attaquer le chiffrement Square. Square est une construction itérative de chiffrement par bloc. Chaque bloc\ncontient \\(128\\) bits et est constitué de \\(16\\) octets rangés dans un tableau de taille\n\\(16\\) (soit un octet dans chaque case). La fonction de tour correspondante est\nconstituée de quatre transformations élémentaires :\n- Linear Transformation\nC’est une transformation linéaire qui opère séparément sur toutes les lignes\nd’un état (state en AES). On peut correspondre cette transformation à un MixColumns\n- Nonlinear Transformation\nC’est une transformation non linéaire qui opère sur chaque octet séparément. On peut la correspondre au SubBytes ou la Sbox en AES.\n- Byte Permutation\nCette permutation correspond à une transposition qui appliquée à un tableau\nd’octets échange les lignes et les colonnes. On peut la correspondre au ShiftRows de l’AES.\n- Bitwise RoundKey Addition\nComme son nom l’indique, c’est une addition bit à bit avec la\nsous-clé de tour. On peut la correspondre à un AddRoundKey de l’AES.\nL’attaque carré fonctionne sur les chiffrements qui possèdent une structure dite carrée inspirée du chiffrement ci-dessus, mais pas que car elle fut plus tard généralisé aux chiffrements ne possédant pas cette structure. Cependant elle reste valable pour l’AES car il hérite de nombreuses propriétés du chiffrement Square.\nPrincipe de l’attaque Nous allons nous baser sur ce qui est décrit ici pour expliquer l’attaque.\nL’attaque square est dite CPA (chosen-plaintext attack) ou encore à clair choisi. L’objectif de l’attaque est de retrouver intégralement la clé et donc de casser l’AES à 4 tours puis à 5. La fonction qui produit les sous-clés à partir de la clé initiale étant inversible, retrouver une sous-clé permet de remonter jusqu’à la clé initiale. L’attaque permet de retrouver la dernière sous-clé (utilisée dans le dernier tour) afin de casser le chiffrement.\n\\(\\Lambda\\)-set Considérons un ensemble de 256 textes en clairs où on choisit un indice sur toutes ces 256 états et qu’on lui fait prendre toutes les valeurs possibles d’un octet (de 0x00 à 0xff) et on laisse tous les autres indice à 0x00. On appellera ce genre d’ensemble un \\(\\Lambda\\)-set (on dit delta-set, ne me demandez pas pourquoi c’est pas lambda-set :)). L’indice qui prend toutes les valeurs possibles est dit actif. Plus généralement, soit \\(\\Lambda\\)-set un ensemble de 256 états différents présentée sous forme de matrice \\(4 \\times 4\\). Représentons par \\(x_{ij}\\) l’octet d’indice \\((i; j)\\) ( \\(i^{ème}\\) ligne et à la \\(j^{ème}\\) colonne ) de \\(x \\in \\Lambda\\)-set. L’octet d’ indice \\((i; j)\\) est dit actif, si tous les octets de cet indice de tous les états d’un même \\(\\Lambda\\)-set, sont différents deux-à-deux. L’octet d’indice \\((i; j)\\) est dit passif, s’il est le même pour tous les états. Soit \\(\\lambda\\) l’ensemble des indices des octets dits actif, alors un \\(\\Lambda\\)-set est défini comme suit :\n$$ \\forall x, y \\in \\Lambda, \\begin{cases} x_{ij} \\neq y_{ij} \u0026\\text{si } (i,j) \\in \\Lambda \\\\\\\\ x_{ij} = y_{ij} \u0026\\text{sinon } \\end{cases} $$ Structure persistante sur 3 tours L’application de SubBytes, AddRoundKey ou ShiftRows sur un \\(\\Lambda\\)-set donne un autre \\(\\Lambda\\)-set avec les indices des octets actifs inchangés. L’application de MixColumns n’aboutit pas nécessairement à un \\(\\Lambda\\)-set. Mais, une colonne d’entrée avec un seul octet actif donne une colonne de sortie avec quatre octets actifs.\nAddRoundKey SubBytes ShiftRows MixColumns A la fin du 1er tour, on obtient donc toujours un \\(\\Lambda\\)-set avec 4 indices actifs. A la fin du 2ème tour, on obtient un \\(\\Lambda\\)-set avec tous les indices qui sont actifs. Le MixColumns du 3ème tour détruit notre \\(\\Lambda\\)-set. . Comme on peut le voir en image notre \\(\\Lambda\\)-set est détruit à la sortie du MixColumns du 3ème tour.\nImaginons donc qu’on prend l’indice \\((i,j)\\) de tous les états de notre \\(\\Lambda\\)-set détruit juste après le MixColumns et appliquons un XOR entre eux tous. On constate que le résultat de ce XOR est \\(0\\). En effet:\nAvant l’entrée dans le MixColumns on a un \\(\\Lambda\\)-set, désignos par \\(a_{ij}\\) l’octet à la position \\(j\\) de l’état \\(i\\) Rappelons nous du fonctionnement du MixColumns. il transforme une colonne $$\\begin{bmatrix} a_0 \\\\\\\\ a_1 \\\\\\\\ a_2 \\\\\\\\ a_3 \\\\\\\\ \\end{bmatrix}$$ en $$\\begin{bmatrix} 2a_0+3a_1+1a_2+1a_3 \\\\\\\\ 1a_0+2a_1+3a_2+1a_3 \\\\\\\\ 1a_0+1a_1+2a_2+3a_3 \\\\\\\\ 3a_0+1a_1+1a_2+2a_3 \\\\\\\\ \\end{bmatrix} $$ Et donc dans notre cas on a : Et qui se simplifie par: On a donc une relation entre les éléments de notre \\(\\Lambda\\)-set. On dit alors que la sortie du 3ème tour est équilibrée.\nAttaquer l’AES à 4 tours A la fin du 3ème tour, an a donc une relation entre les éléments de notre \\(\\Lambda\\)-set. En ajoutant un tour de plus, on constate que notre observation n’est plus vraie après le SubBytes. On voit là en bleu que le SubByte casse notre structure en rouge.\nMais imaginons qu’on essaye de deviner un octet à la position \\(i\\) de la dernière sous-clé.\nConcentrons nous sur cette position \\(i\\) de tous les 256 états. On fait l’inverse du AddRoundKey qui est lui même, celui-ci agira sur cette position uniquement sans l’influencer avec d’autres octets, pareil pour l’inverse du ShiftRows et l’inverse du SubBytes. A la sortie de l’inverse du SubBytes, on se retrouve dans l’état où on avait fait notre constat. Et notre constat devrait toujours être valide à ce stade. Il suffit donc une fois à cette étape de faire le XOR de tous les octets à la position \\(i\\) de tous les 256 états à cette position et de vérifier si on obtient \\(0\\). Si oui, alors ça veut dire qu’on a obtenu la bonne dernière sous-clé. On peut donc itérer ce processus et trouver la dernière sous-clé octet par octet. Cependant il peut y avoir des faux positifs. On peut avoir pour un même \\(\\Lambda\\)-set plusieurs octets qui répondent aux critères de l’octet qu’on essaye de deviner. Dans ce cas, il faudra changer de \\(\\Lambda\\)-set et tester ces octets afin d’éliminer les faux positifs.\nVous pouvez trouver une implémentation assez complète ici: https://github.com/thomasperrot/aes-square-attack.\nOn peut le tester. Comme dit dans le README, on va implémenter la fonction dont la signature est def encrypt_delta_set(delta_set: Iterable[State]) -\u003e List[State]:, elle permettra de chiffrer les \\(\\Lambda\\)-set qui lui seront envoyés en paramètre.\nIci, on dispose d’un oracle de chiffrement qui implémente un AES-128 réduit à 4 tours et où on peut chiffrer autant de clair qu’on veut.\nC:\\Users\\dilag\\Documents\\cryptanalysis\\aes 4 tours\\aes-square-attack\u003encat 192.168.0.1 5050 Commands are: |-\u003e e Encrypt the plaintext block with 4-round AES-128 |-\u003e c Check whether the block is the secret key |-\u003e q Quit e 010000000000000000000000000000000 Error: the plaintext must contain 32 hexadecimal digits ([0-9a-f]) e 10000000000000000000000000000000 d11335db039b7688924c9d4ad4068051 Voici donc notre implémentation utilisant le petit package du github\nfrom typing import Iterable, List from aes.common import State from pwn import * import numpy as np import binascii from aes.square import crack_key context.log_level = 'debug' global conn def tostate(plaintext=b''): state = np.array(list(plaintext), dtype=int) state = np.reshape(state, (4, 4), order='F') return state def encrypt_delta_set(delta_set: Iterable[State]) -\u003e List[State]: global conn states = [] for s in delta_set: hex_bytes = binascii.hexlify(((bytes(list(np.reshape(s, 16, order='F')))))) conn.sendline(b'e ' + hex_bytes) res = conn.recvline() res = res.strip() states.append(tostate(binascii.unhexlify(res))) return states if __name__ == '__main__': conn = remote('192.168.0.1',5050) conn.recvuntil(b'Quit\\n') conn.recvline() cracked_key = crack_key(encrypt_delta_set) print(f\"[+] Found key: {binascii.hexlify(cracked_key)}\") conn.close() Après exécution :\n[+] Opening connection to 192.168.0.1 on port 5050: Done [+] Found key: b'7473f9bfec7414027c10e4fbcc979c00' [*] Closed connection to 192.168.0.1 port 5050 Et voilà on a récupérer la clé de chiffrement.\n","wordCount":"1387","inLanguage":"en","datePublished":"2023-07-19T02:08:37+02:00","dateModified":"2023-07-19T02:08:37+02:00","author":{"@type":"Person","name":"dilag","url":"https://dilagluc.github.io/en/about-dilag/"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dilagluc.github.io/en/posts/2023/crypto/aes/square-attack-aes/"},"publisher":{"@type":"Organization","name":"Blog","description":"Continuing Hermit\u0026#39;s legacy to be minimal and fast theme","logo":{"@type":"ImageObject","url":"https://dilagluc.github.io/favicon.ico"}}}</script><title>Cryptanalyse intégrale sur AES à tours réduits: l'attaque dite carrée</title><link rel="stylesheet dns-prefetch preconnect preload prefetch" as=style media=screen href=https://dilagluc.github.io/css/style.min.cbb61c13ffe36e23de11896ce5cb9f37cf539353029dd4d553dddd3403b2d24e.css integrity="sha256-y7YcE//jbiPeEYls5cufN89Tk1MCndTVU93dNAOy0k4=" crossorigin=anonymous></head><body id=page><header id=site-header><div class="hdr-wrapper section-inner"><div class=hdr-left><div class=site-branding><a href=https://dilagluc.github.io/>Blog</a></div><nav class="site-nav hide-in-mobile"><a href=https://dilagluc.github.io/en/posts/>Posts</a><a href=https://dilagluc.github.io/en/about-dilag/>About Me</a></nav></div><div class="hdr-right hdr-icons"><span class="hdr-links hide-in-mobile"><a href=https://github.com/dilagluc/ target=_blank rel="noopener me" title=Github><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://github.com/1bl4z3r/hermit-V2/tree/staging target=_blank rel="noopener me" title=Discord><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M8.82889 11.203C7.86239 11.203 7.09937 12.0508 7.09937 13.0852c0 1.0343.779979999999999 1.8821 1.72952 1.8821C9.79538 14.9673 10.5584 14.1195 10.5584 13.0852 10.5754 12.0508 9.79538 11.203 8.82889 11.203zm6.18891.0c-.9664.0-1.7295.847800000000001-1.7295 1.8822.0 1.0343.780000000000001 1.8821 1.7295 1.8821.9665.0 1.7296-.847799999999999 1.7296-1.8821.0-1.0344-.7631-1.8822-1.7296-1.8822z" fill="currentcolor"/><path d="M14.8477 18.3649C14.8874 18.4483 14.9381 18.5296 15.0005 18.6075 15.3663 19.0644 15.7387 19.5135 15.8832 19.687 16.1242 19.9764 16.4855 20.1329 16.8553 20.117c3.8286-.1648 5.55-2.5107 5.8573-2.9828C22.8526 16.919 22.9029 16.6887 22.9023 16.4867 22.8862 11.0873 20.6126 6.69288 20.3618 6.22299 20.2686 6.04849 20.1448 5.9213 20.0223 5.83024c-2.3899-1.77582-4.6825-1.93766-5.2236-1.95079C14.4248 3.87037 14.1018 4.039 13.8908 4.28019 13.7833 4.40298 13.7069 4.53817 13.659 4.67843 12.4808 4.5498 11.3488 4.5684 10.3271 4.681 10.2848 4.54257 10.2137 4.40813 10.1111 4.28494 9.90289 4.03513 9.58304 3.87239 9.22517 3.87894 8.72884 3.88801 6.40341 4.02781 3.9777 5.83024 3.85516 5.9213 3.73139 6.04849 3.63825 6.22299c-.25083.4699-2.5246 4.86461-2.54051 10.26431C1.09715 16.6871 1.14634 16.9155 1.28416 17.1296 1.58866 17.6027 3.29601 19.9515 7.12649 20.1169 7.50079 20.1331 7.86486 19.9726 8.10512 19.6794 8.2521 19.5 8.63516 19.0311 9.00416 18.5683 9.06865 18.4874 9.12057 18.4028 9.16075 18.316 9.32759 18.3546 9.49869 18.391 9.67405 18.4248L9.68004 18.426C11.0465 18.681 12.6626 18.7747 14.4312 18.4443 14.5698 18.4206 14.7086 18.3942 14.8477 18.3649z" stroke="currentcolor" stroke-width="2"/></svg></a><a href=https://x.com/dilag_luc target=_blank rel="noopener me" title=X><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path class="st0" d="m21.3 21.1L9.9 2.9H2.7l11.4 18.2zm-18.6.0 7.2-6.6m4.2-5 7.2-6.6"/></svg></a></span><button id=share-btn class=hdr-btn title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-share-2"><circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/></svg></button><div id=share-links class="animated fast"><ul><li><a href="https://twitter.com/intent/tweet?hashtags=hermit2&amp;url=https%3a%2f%2fdilagluc.github.io%2fen%2fposts%2f2023%2fcrypto%2faes%2fsquare-attack-aes%2f&amp;text=Cryptanalyse%20int%c3%a9grale%20sur%20AES%20%c3%a0%20tours%20r%c3%a9duits%3a%20l%27attaque%20dite%20carr%c3%a9e" target=_blank rel=noopener aria-label="Share on X"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path class="st0" d="m21.3 21.1L9.9 2.9H2.7l11.4 18.2zm-18.6.0 7.2-6.6m4.2-5 7.2-6.6"/></svg></a></li><li><a href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fdilagluc.github.io%2fen%2fposts%2f2023%2fcrypto%2faes%2fsquare-attack-aes%2f" target=_blank rel=noopener aria-label="Share on Facebook"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 2h-3a5 5 0 00-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 011-1h3z"/></svg></a></li><li><a href="mailto:?subject=Cryptanalyse%20int%c3%a9grale%20sur%20AES%20%c3%a0%20tours%20r%c3%a9duits%3a%20l%27attaque%20dite%20carr%c3%a9e&amp;body=https%3a%2f%2fdilagluc.github.io%2fen%2fposts%2f2023%2fcrypto%2faes%2fsquare-attack-aes%2f" target=_self rel=noopener aria-label="Share on Email"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></li><li><a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fdilagluc.github.io%2fen%2fposts%2f2023%2fcrypto%2faes%2fsquare-attack-aes%2f&amp;source=https%3a%2f%2fdilagluc.github.io%2f&amp;title=Cryptanalyse%20int%c3%a9grale%20sur%20AES%20%c3%a0%20tours%20r%c3%a9duits%3a%20l%27attaque%20dite%20carr%c3%a9e&amp;summary=Cryptanalyse%20int%c3%a9grale%20sur%20AES%20%c3%a0%20tours%20r%c3%a9duits%3a%20l%27attaque%20dite%20carr%c3%a9e%2c%20by%20dilag%0a%0asquare%20attack%20on%20reduced%20AES%20rounds%0a" target=_blank rel=noopener aria-label="Share on LinkedIn"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></li><li><a href=# onclick='return linkShare("Cryptanalyse intégrale sur AES à tours réduits: l&#39;attaque dite carrée","https://dilagluc.github.io/en/posts/2023/crypto/aes/square-attack-aes/",`Cryptanalyse intégrale sur AES à tours réduits: l&#39;attaque dite carrée, by dilag

square attack on reduced AES rounds
`),!1' target=_self rel=noopener aria-label="Copy Link"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-copy"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg></a></li></ul></div><button id=menu-btn class=hdr-btn title=Menu><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button></div></div></header><div id=mobile-menu class="animated fast"><ul><li><a href=https://dilagluc.github.io/en/posts/>Posts</a></li><li><a href=https://dilagluc.github.io/en/about-dilag/>About Me</a></li></ul></div><main class="site-main section-inner animated fadeIn faster"><article class=thin><header class=post-header><div class=post-date><span>Jul 19, 2023</span></div><h1>Cryptanalyse intégrale sur AES à tours réduits: l'attaque dite carrée</h1></header><div class=post-description><p>square attack on reduced AES rounds</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-feather"><path d="M20.24 12.24a6 6 0 00-8.49-8.49L5 10.5V19h8.5z"/><line x1="16" y1="8" x2="2" y2="22"/><line x1="17.5" y1="15" x2="9" y2="15"/></svg><a href=https://dilagluc.github.io/en/about-dilag/ target=_blank>dilag</a></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=https://dilagluc.github.io/en/tags/crypto>crypto</a></span><span class=tag><a href=https://dilagluc.github.io/en/tags/aes>aes</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>1387&nbspWords … ⏲ Reading Time:6 Minutes, 18 Seconds</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2023-07-19 00:08 +0000</p></div><hr class=post-end><div class=content><p>Dans l&rsquo;article <a href=/blog/2023/crypto/aes/intro>Chiffrement AES - Introduction</a> , on a eu à étudier et comprendre le fonctionnement du chiffrement AES. On se pose maintenant la question de savoir quelles sont les attaques possibles sur ce chiffrement. Dans cet article, nous étudierons l&rsquo;attaque dite carrée sur un AES à tours réduits.</p><h2 id=introduction>Introduction<a href=#introduction class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>La cryptanalyse intégrale est une technique de cryptanalyse applicable sur les chiffrements par blocs basés sur un réseau de substitution-permutation. Elle a été conçu pour la première fois pour attaquer un chiffrement du nom de <strong>SQUARE</strong> (d&rsquo;où le nom square attack), mais fut plus tard généralisée à d&rsquo;autres algorithmes de chiffrement qui ne sont pas de type <strong>SQUARE</strong>. Elle est plus généralement connu sous le nom d&rsquo;attaque carrée (square attack).<br>La cryptanalyse intégrale utilise un ensemble ou plusieurs ensembles de clairs choisis dont une partie reste constante et l&rsquo;autre partie varie couvrant toutes les possibilités.<br>On verra dans la suite comment fonctionne ce type d&rsquo;attaque sur un chiffrement AES à tours réduits.</p><h2 id=lattaque-carrée>L&rsquo;attaque carrée<a href=#lattaque-carr%c3%a9e class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>Comme dit précédemment cette attaque avait été conçu pour attaquer le chiffrement <strong>Square</strong>.
<strong>Square</strong> est une construction itérative de chiffrement par bloc. Chaque bloc<br>contient \(128\) bits et est constitué de \(16\) octets rangés dans un tableau de taille<br>\(16\) (soit un octet dans chaque case). La fonction de tour correspondante est<br>constituée de quatre transformations élémentaires :<br><strong>- Linear Transformation</strong><br>C’est une transformation linéaire qui opère séparément sur toutes les lignes<br>d’un état (state en AES). On peut correspondre cette transformation à un MixColumns<br><strong>- Nonlinear Transformation</strong><br>C&rsquo;est une transformation non linéaire qui opère sur chaque octet séparément.
On peut la correspondre au SubBytes ou la Sbox en AES.<br><strong>- Byte Permutation</strong><br>Cette permutation correspond à une transposition qui appliquée à un tableau<br>d’octets échange les lignes et les colonnes. On peut la correspondre au ShiftRows de l’AES.<br><strong>- Bitwise RoundKey Addition</strong><br>Comme son nom l’indique, c’est une addition bit à bit avec la<br>sous-clé de tour. On peut la correspondre à un AddRoundKey de l’AES.<br>L’attaque carré fonctionne sur les chiffrements qui possèdent une structure dite carrée inspirée du chiffrement ci-dessus, mais pas que car elle fut plus tard généralisé aux chiffrements ne possédant pas cette structure. Cependant elle reste valable pour l’AES car il hérite de nombreuses propriétés du chiffrement Square.</p><h2 id=principe-de-lattaque>Principe de l&rsquo;attaque<a href=#principe-de-lattaque class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>Nous allons nous baser sur ce qui est décrit <a href=https://www.davidwong.fr/blockbreakers/square_1_3rounds.html>ici</a> pour expliquer l&rsquo;attaque.<br>L’attaque square est dite CPA (chosen-plaintext attack) ou encore à clair choisi. L’objectif de l’attaque est de retrouver intégralement la clé et donc de casser l’AES à 4 tours puis à 5. La fonction qui produit les sous-clés à partir de la clé initiale étant inversible, retrouver une sous-clé permet de remonter jusqu’à la clé initiale. L&rsquo;attaque permet de retrouver la dernière sous-clé (utilisée dans le dernier tour) afin de casser le chiffrement.</p><h4 id=lambda-set>\(\Lambda\)-set<a href=#lambda-set class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>Considérons un ensemble de 256 textes en clairs où on choisit un indice sur toutes ces 256 états et qu&rsquo;on lui fait prendre toutes les valeurs possibles d&rsquo;un octet (de 0x00 à 0xff) et on laisse tous les autres indice à 0x00. On appellera ce genre d&rsquo;ensemble un <strong>\(\Lambda\)-set</strong> (on dit delta-set, ne me demandez pas pourquoi c&rsquo;est pas lambda-set :)). L&rsquo;indice qui prend toutes les valeurs possibles est dit <strong>actif</strong>. Plus généralement, soit \(\Lambda\)-set un ensemble de 256 états différents présentée sous forme de matrice \(4 \times 4\). Représentons par \(x_{ij}\) l’octet d’indice \((i; j)\) ( \(i^{ème}\) ligne et à la \(j^{ème}\) colonne ) de \(x \in \Lambda\)-set.
L&rsquo;octet d&rsquo; indice \((i; j)\) est dit <strong>actif</strong>, si tous les octets de cet indice de tous les états d’un même \(\Lambda\)-set, sont différents deux-à-deux. L&rsquo;octet d&rsquo;indice \((i; j)\) est dit <strong>passif</strong>, s’il est le même pour tous les états. Soit \(\lambda\) l’ensemble des indices des octets dits actif, alors un \(\Lambda\)-set est défini comme suit :<br></p>$$
\forall x, y \in \Lambda,
\begin{cases}
x_{ij} \neq y_{ij} &\text{si } (i,j) \in \Lambda \\\\
x_{ij} = y_{ij} &\text{sinon }
\end{cases}
$$<h4 id=structure-persistante-sur-3-tours>Structure persistante sur 3 tours<a href=#structure-persistante-sur-3-tours class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>L’application de SubBytes, AddRoundKey ou ShiftRows sur un \(\Lambda\)-set donne un autre \(\Lambda\)-set avec les indices des octets actifs inchangés. L’application de MixColumns n’aboutit pas nécessairement à un \(\Lambda\)-set. Mais, une colonne d’entrée avec un seul octet actif donne une colonne de sortie avec quatre octets actifs.</p><ul><li>AddRoundKey<figure><img src=https://dilagluc.github.io/crypto_aes/delta_AddRoundKey.png></figure></li><li>SubBytes<figure><img src=https://dilagluc.github.io/crypto_aes/delta_SubBytes.png></figure></li><li>ShiftRows<figure><img src=https://dilagluc.github.io/crypto_aes/delta_ShiftRows.png></figure></li><li>MixColumns<figure><img src=https://dilagluc.github.io/crypto_aes/delta_MixColumns.png></figure></li></ul><p>A la fin du 1er tour, on obtient donc toujours un \(\Lambda\)-set avec 4 indices actifs. A la fin du 2ème tour, on obtient un \(\Lambda\)-set avec tous les indices qui sont actifs. Le MixColumns du 3ème tour détruit notre \(\Lambda\)-set.<figure><img src=https://dilagluc.github.io/crypto_aes/delta_3tours.png></figure>.
Comme on peut le voir en image notre \(\Lambda\)-set est détruit à la sortie du MixColumns du 3ème tour.<br>Imaginons donc qu&rsquo;on prend l&rsquo;indice \((i,j)\) de tous les états de notre \(\Lambda\)-set détruit juste après le MixColumns et appliquons un XOR entre eux tous. On constate que le résultat de ce XOR est \(0\). En effet:<br>Avant l&rsquo;entrée dans le MixColumns on a un \(\Lambda\)-set, désignos par \(a_{ij}\) l&rsquo;octet à la position \(j\) de l&rsquo;état \(i\) Rappelons nous du fonctionnement du MixColumns. il transforme une colonne</p>$$\begin{bmatrix}
a_0 \\\\
a_1 \\\\
a_2 \\\\
a_3 \\\\
\end{bmatrix}$$<p>en</p>$$\begin{bmatrix}
2a_0+3a_1+1a_2+1a_3 \\\\
1a_0+2a_1+3a_2+1a_3 \\\\
1a_0+1a_1+2a_2+3a_3 \\\\
3a_0+1a_1+1a_2+2a_3 \\\\
\end{bmatrix} $$<p>Et donc dans notre cas on a :<figure><img src=https://dilagluc.github.io/crypto_aes/xor1.png></figure>Et qui se simplifie par:<figure><img src=https://dilagluc.github.io/crypto_aes/xor2.png></figure>On a donc une relation entre les éléments de notre \(\Lambda\)-set. On dit alors que la sortie du 3ème tour est équilibrée.</p><h4 id=attaquer-laes-à-4-tours>Attaquer l&rsquo;AES à 4 tours<a href=#attaquer-laes-%c3%a0-4-tours class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>A la fin du 3ème tour, an a donc une relation entre les éléments de notre \(\Lambda\)-set. En ajoutant un tour de plus, on constate que notre observation n&rsquo;est plus vraie après le SubBytes.<figure><img src=https://dilagluc.github.io/crypto_aes/unknown.png></figure>On voit là en bleu que le SubByte casse notre structure en rouge.<br>Mais imaginons qu&rsquo;on essaye de deviner un octet à la position \(i\) de la dernière sous-clé.<br>Concentrons nous sur cette position \(i\) de tous les 256 états. On fait l&rsquo;inverse du AddRoundKey qui est lui même, celui-ci agira sur cette position uniquement sans l&rsquo;influencer avec d&rsquo;autres octets, pareil pour l&rsquo;inverse du ShiftRows et l&rsquo;inverse du SubBytes. A la sortie de l&rsquo;inverse du SubBytes, on se retrouve dans l&rsquo;état où on avait fait notre constat. Et notre constat devrait toujours être valide à ce stade. Il suffit donc une fois à cette étape de faire le XOR de tous les octets à la position \(i\) de tous les 256 états à cette position et de vérifier si on obtient \(0\). Si oui, alors ça veut dire qu&rsquo;on a obtenu la bonne dernière sous-clé. On peut donc itérer ce processus et trouver la dernière sous-clé octet par octet. Cependant il peut y avoir des faux positifs. On peut avoir pour un même \(\Lambda\)-set plusieurs octets qui répondent aux critères de l&rsquo;octet qu&rsquo;on essaye de deviner. Dans ce cas, il faudra changer de \(\Lambda\)-set et tester ces octets afin d&rsquo;éliminer les faux positifs.<br>Vous pouvez trouver une implémentation assez complète ici: <a href=https://github.com/thomasperrot/aes-square-attack>https://github.com/thomasperrot/aes-square-attack</a>.<br>On peut le tester. Comme dit dans le README, on va implémenter la fonction dont la signature est <code>def encrypt_delta_set(delta_set: Iterable[State]) -> List[State]:</code>, elle permettra de chiffrer les \(\Lambda\)-set qui lui seront envoyés en paramètre.<br>Ici, on dispose d&rsquo;un oracle de chiffrement qui implémente un AES-128 réduit à 4 tours et où on peut chiffrer autant de clair qu&rsquo;on veut.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>C:\Users\dilag\Documents\cryptanalysis\aes <span style=color:#ae81ff>4</span> tours\aes-square-attack&gt;ncat <span style=color:#ae81ff>192.168</span>.0.1 <span style=color:#ae81ff>5050</span>
</span></span><span style=display:flex><span>Commands are<span style=color:#960050;background-color:#1e0010>:</span>
</span></span><span style=display:flex><span>|-&gt; e &lt;block&gt;   Encrypt the plaintext block with <span style=color:#ae81ff>4</span>-round AES-<span style=color:#ae81ff>128</span>
</span></span><span style=display:flex><span>|-&gt; c &lt;block&gt;   Check whether the block is the secret key
</span></span><span style=display:flex><span>|-&gt; q           Quit
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>e <span style=color:#ae81ff>010000000000000000000000000000000</span>
</span></span><span style=display:flex><span>Error<span style=color:#960050;background-color:#1e0010>:</span> the plaintext must contain <span style=color:#ae81ff>32</span> hexadecimal digits ([<span style=color:#ae81ff>0</span>-9a<span style=color:#f92672>-f</span>])
</span></span><span style=display:flex><span>e <span style=color:#ae81ff>10000000000000000000000000000000</span>
</span></span><span style=display:flex><span>d11335db039b7688924c9d4ad4068051
</span></span></code></pre></div><p>Voici donc notre implémentation utilisant le petit package du github</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> typing <span style=color:#f92672>import</span> Iterable, List
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> aes.common <span style=color:#f92672>import</span> State
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pwn <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> binascii
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> aes.square <span style=color:#f92672>import</span> crack_key
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>context<span style=color:#f92672>.</span>log_level <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;debug&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>global</span> conn
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>tostate</span>(plaintext<span style=color:#f92672>=</span><span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;&#39;</span>):
</span></span><span style=display:flex><span>    state <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array(list(plaintext), dtype<span style=color:#f92672>=</span>int)
</span></span><span style=display:flex><span>    state <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>reshape(state, (<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>4</span>), order<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;F&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> state
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>encrypt_delta_set</span>(delta_set: Iterable[State]) <span style=color:#f92672>-&gt;</span> List[State]:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>global</span> conn
</span></span><span style=display:flex><span>    states <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> s <span style=color:#f92672>in</span> delta_set:
</span></span><span style=display:flex><span>        hex_bytes <span style=color:#f92672>=</span> binascii<span style=color:#f92672>.</span>hexlify(((bytes(list(np<span style=color:#f92672>.</span>reshape(s, <span style=color:#ae81ff>16</span>, order<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;F&#39;</span>))))))
</span></span><span style=display:flex><span>        conn<span style=color:#f92672>.</span>sendline(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;e &#39;</span> <span style=color:#f92672>+</span> hex_bytes)
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> conn<span style=color:#f92672>.</span>recvline()
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> res<span style=color:#f92672>.</span>strip()
</span></span><span style=display:flex><span>        states<span style=color:#f92672>.</span>append(tostate(binascii<span style=color:#f92672>.</span>unhexlify(res)))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> states
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:  
</span></span><span style=display:flex><span>    conn <span style=color:#f92672>=</span> remote(<span style=color:#e6db74>&#39;192.168.0.1&#39;</span>,<span style=color:#ae81ff>5050</span>)
</span></span><span style=display:flex><span>    conn<span style=color:#f92672>.</span>recvuntil(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;Quit</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>    conn<span style=color:#f92672>.</span>recvline()
</span></span><span style=display:flex><span>    cracked_key <span style=color:#f92672>=</span> crack_key(encrypt_delta_set)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[+] Found key: </span><span style=color:#e6db74>{</span>binascii<span style=color:#f92672>.</span>hexlify(cracked_key)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    conn<span style=color:#f92672>.</span>close()
</span></span></code></pre></div><p>Après exécution :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> Opening connection to 192.168.0.1 on port 5050: Done
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> Found key: b<span style=color:#e6db74>&#39;7473f9bfec7414027c10e4fbcc979c00&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>*<span style=color:#f92672>]</span> Closed connection to 192.168.0.1 port <span style=color:#ae81ff>5050</span>
</span></span></code></pre></div><p>Et voilà on a récupérer la clé de chiffrement.</p></div><div class="related-posts thin"><h2>See Also</h2><ul><li><a href=/en/posts/2023/crypto/aes/intro-to-aes/>Chiffrement AES</a></li></ul></div></article><div class="post-nav thin"><a class=next-post href=https://dilagluc.github.io/en/posts/2024/cve_analysis/tplink_cve_2024_1179/><span class=post-nav-label><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></svg>&nbsp;Newer</span><br><span>TP Link CVE-2024-1179 analysis</span>
</a><a class=prev-post href=https://dilagluc.github.io/en/posts/2023/crypto/aes/intro-to-aes/><span class=post-nav-label>Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg></span><br><span>Chiffrement AES</span></a></div><div id=comments class=thin></div></main><footer id=site-footer class="section-inner thin animated fadeIn faster"><p>&copy; 2025 <a href=https://dilagluc.github.io/>Blog</a>
&#183; <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>dilag</a>&#183; Made with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a>
&#183; Theme <a href=https://github.com/1bl4z3r/hermit-V2 target=_blank rel=noopener>Hermit-V2</a></p></footer><script async src=https://dilagluc.github.io/js/bundle.min.c7c384e4d29d192bbac6811ae4660bb01767194a5bea56baca77e8260f93ea16.js integrity="sha256-x8OE5NKdGSu6xoEa5GYLsBdnGUpb6la6ynfoJg+T6hY=" crossorigin=anonymous></script><script async src=https://dilagluc.github.io/js/link-share.min.24409a4f6e5537d70ffc55ec8f9192208d718678cb8638585342423020b37f39.js integrity="sha256-JECaT25VN9cP/FXsj5GSII1xhnjLhjhYU0JCMCCzfzk=" crossorigin=anonymous></script><script id=MathJax-script type=text/javascript async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js crossorigin=anonymous></script><script type=text/javascript id=MathJax-script-helper async src=https://dilagluc.github.io/js/mathjax-assistant.min.ca29e9d446b2a6cb6c6e3eb0d47e9693f5c306c146eaccb43047afbf31b07a6f.js integrity="sha256-yinp1Eaypstsbj6w1H6Wk/XDBsFG6sy0MEevvzGwem8=" crossorigin=anonymous></script></body></html>